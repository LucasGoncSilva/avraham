{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Homepage","text":"Mosheh  <p>Mosheh, a tool for creating docs for projects, from Python to Python.</p> <p>Basically, Mosheh lists all files you points to, saves every single notorious statement of definition on each file iterated, all using Python <code>ast</code> native module for handling the AST and then generating with MkDocs and Material MkDocs a documentation respecting the dirs and files hierarchy. The stuff documented for each file are listed below:</p> <ul> <li> <p>Imports <code>[ast.Import | ast.ImportFrom]</code></p> </li> <li> <p> Type <code>[Native | TrdParty | Local]</code></p> </li> <li> Path (e.g. 'django.http')</li> <li> <p> Code</p> </li> <li> <p>Constants <code>[ast.Assign | ast.AnnAssign]</code></p> </li> <li> <p> Name (token name)</p> </li> <li> Typing Notation (datatype)</li> <li> Value (literal or call)</li> <li> <p> Code</p> </li> <li> <p>Classes <code>[ast.ClassDef]</code></p> </li> <li> <p> Description (docstring)</p> </li> <li> Name (class name)</li> <li> Parents (inheritance)</li> <li> Methods Defined (nums and names)</li> <li> Example (usage)</li> <li> <p> Code</p> </li> <li> <p>Funcs <code>[ast.FunctionDef | ast.AsyncFunctionDef]</code></p> </li> <li> <p> Description (docstring)</p> </li> <li> Name (func name)</li> <li> Type <code>[Func | Method | Generator | Coroutine]</code></li> <li> Parameters (name, type, default)</li> <li> Return Type (datatype)</li> <li> Raises (exception throw)</li> <li> Example (usage)</li> <li> <p> Code</p> </li> <li> <p>Assertions <code>[ast.Assert]</code></p> </li> <li> <p> Test (assertion by itself)</p> </li> <li> Message (opt. message in fail case)</li> <li> Code</li> </ul>"},{"location":"#stack","title":"Stack","text":""},{"location":"#todo-list","title":"ToDo List","text":"<ul> <li> Evaluate use of Rust for better proccessing</li> <li> Evaluate the processing of more files than just Python ones (e.g. <code>.txt</code>, <code>.toml</code>)</li> <li> Migrate dependency system to use uv</li> <li> Process 25% of Python AST's nodes on <code>mosheh.handler</code></li> <li> Process 50% of Python AST's nodes on <code>mosheh.handler</code></li> <li> Process 75% of Python AST's nodes on <code>mosheh.handler</code></li> <li> Process 100% of Python AST's nodes on <code>mosheh.handler</code></li> <li> Accept structured file (e.g. <code>mosheh.json</code>) as parameters replacement</li> <li> Provide an \"exclude\" config for files/dirs to ignore</li> <li> Insert <code>tags</code> for <code>.md</code> based on their names/contexts</li> <li> Get and list all metrics of above's statements featured</li> <li> Check for files docstrings and write below filepath</li> <li> Create detail page for classes with docstring and listing class constants and methods</li> <li> Create detail page for functions with docstring and body detail</li> </ul>"},{"location":"#arch","title":"Arch","text":"<p>Mosheh's architecture can be interpreted in two ways: the directory structure and the interaction of the elements that make it up. A considerable part of a project is - or at least should be - that elements that are dispensable for its functionality are in fact dispensable, such as the existence of automated tests; they are important so that any existing quality process is kept to a minimum acceptable level, but if all the tests are deleted, the tool still works.</p> <p>Here it is no different, a considerable part of Mosheh is, in fact, completely dispensable; follow below the structure of directories and relevant files that are part of this project:</p> Bash<pre><code>.\n\u251c\u2500\u2500 mosheh                      # Mosheh's source-code\n\u2502   \u251c\u2500\u2500 codebase.py             # Codebase reading logic\n\u2502   \u251c\u2500\u2500 constants.py            # Constants to be evaluated\n\u2502   \u251c\u2500\u2500 custom_types.py         # Custom data types\n\u2502   \u251c\u2500\u2500 doc.py                  # Documentation build logic\n\u2502   \u251c\u2500\u2500 handlers.py             # Codebase nodes handlers functions\n\u2502   \u251c\u2500\u2500 main.py                 # Entrypoint\n\u2502   \u251c\u2500\u2500 metadata.py             # Metadata about Mosheh itself\n\u2502   \u2514\u2500\u2500 utils.py                # Utilities\n\u2502\n\u251c\u2500\u2500 tests                       # Template dir for testing\n\u2502   \u251c\u2500\u2500 DOC                     # Doc output dir\n\u2502   \u251c\u2500\u2500 PROJECT                 # Template project dir\n\u2502   \u2514\u2500\u2500 unittest                # Automated tests\n\u2502\n\u251c\u2500\u2500 documentation               # Mosheh's documentation dir\n\u2502   \u251c\u2500\u2500 docs                    # Dir containing .md files and assets\n\u2502   \u2514\u2500\u2500 mkdocs.yml              # MkDocs config file\n\u2502\n\u251c\u2500\u2500 pyproject.toml              # Mosheh's config file for almost everything\n\u251c\u2500\u2500 uv.lock                     # uv's lockfile for dealing with dependencies\n\u251c\u2500\u2500 .python-version             # Default Python's version to use\n\u2502\n\u251c\u2500\u2500 .github                     # Workflows and social stuff\n\u2502\n\u251c\u2500\u2500 LICENSE                     # Legal stuff, A.K.A donut sue me\n\u2502\n\u2514\u2500\u2500 .gitignore                  # Git \"exclude\" file\n</code></pre> <p>It is to be expected that if the <code>tests/</code> directory is deleted, Mosheh itself will not be altered in any way, so much so that when a tool is downloaded via <code>pip</code> or similar, the tool is not accompanied by tests, licenses, development configuration files or workflows. So, to help you understand how the <code>mosheh/</code> directory works, here's how the functional elements interact with each other:</p> <p></p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#local-build-and-installation","title":"Local Build and Installation","text":""},{"location":"#installing-dependencies","title":"Installing Dependencies","text":"Bash<pre><code>pip install uv  # For installing uv to handle the environment\n\nuv sync  # Automatically creates a .venv, activates it and install libs based on uv.lock and pyproject.toml\n</code></pre>"},{"location":"#runing-locally","title":"Runing Locally","text":"Bash<pre><code>uv run -m mosheh.main  # For running using uv and dealing with Mosheh as a module\n</code></pre>"},{"location":"#installing-locally","title":"Installing Locally","text":"Bash<pre><code>uv build  # Build pip-like file\n\nuv pip install dist/mosheh-&lt;VERSION&gt;-py3-none-any.whl --force-reinstall  # Install Mosheh using generated pip-like file\n</code></pre>"},{"location":"#testing","title":"Testing","text":"Bash<pre><code>uv run pytest  # Run pytest\n</code></pre>"},{"location":"#parameters","title":"Parameters","text":"Call Type Mandatory Default Example Description <code>-h</code>, <code>--help</code> <code>str</code> <code>Optional</code> <code>None</code> <code>-h</code>, <code>--help</code> Help message <code>-root</code> <code>Path</code> <code>Required</code> <code>None</code> <code>-root example/</code> Root dir, where the analysis starts. <code>--repo-name</code> <code>str</code> <code>Optional</code> <code>'GitHub'</code> <code>--repo-name toicin</code> Name of the code repository to be mapped. <code>--repo-url</code> <code>URL</code> <code>Optional</code> <code>'https://github.com/'</code> <code>--repo-url https://random.com</code> URL of the code repository to be mapped. <code>--edit-uri</code> <code>str</code> <code>Optional</code> <code>'blob/main/documentation/docs'</code> <code>--edit-uri blob/main/docs</code> URI to view raw or edit blob file. <code>--logo-path</code> <code>Path</code> <code>Optional</code> <code>None</code> <code>--repo-url .github/logo.svg</code> Path for doc/project logo, same Material MkDocs's formats. <code>--readme-path</code> <code>Path</code> <code>Optional</code> <code>None</code> <code>--repo-url .github/README.md</code> Path for <code>README.md</code> file to used as homepage. <code>--verbose</code> <code>int</code> <code>Optional</code> <code>3</code> - <code>logging.INFO</code> <code>--verbose 4</code> Verbosity level, from 0 (quiet/critical) to 4 (overshare/debug). <code>--output</code> <code>Path</code> <code>Optional</code> <code>'.'</code> - current dir <code>--output doc/</code> Path for documentation output, where to be created."},{"location":"#license","title":"License","text":"<p>This project is under MIT License. A short and simple permissive license with conditions only requiring preservation of copyright and license notices. Licensed works, modifications, and larger works may be distributed under different terms and without source code.</p>"},{"location":"changelog/","title":"Changelog and Update History","text":"<p>A changelog is a document that tracks the history of changes in a project, typically organized by version numbers. It serves as a transparent record for developers, users, and contributors, detailing what has been added, updated, fixed, removed, or addressed in terms of security. By offering a structured overview, changelogs play a vital role in maintaining trust, facilitating communication, and easing version management.</p> <p>Changelogs provide a transparent narrative of a project\u2019s evolution. They ensure users can make informed decisions about updating software and give contributors insights into the project\u2019s direction. For development teams, changelogs are invaluable for version control and accountability. Well-maintained changelogs foster trust, improve user engagement, and ensure smoother project management for all stakeholders.</p> <p>Key Components of a Changelog:</p> <ul> <li>Adds: This section highlights new features, tools, or functionalities introduced to the project. For example, a CLI tool may include a new command or configuration option. Clearly listing these additions allows users to discover improvements and expanded capabilities.</li> <li>Updates: Updates reflect modifications or enhancements to existing features, such as performance optimizations or UI/UX improvements. These entries help users understand what has evolved, ensuring they benefit from improved usability or efficiency.</li> <li>Fixes: Fixes document the resolution of bugs or issues. By specifying what was corrected, users gain confidence that problems they may have encountered have been addressed, reducing frustration.</li> <li>Removes: Sometimes, features or functionalities are deprecated or removed. Listing these changes prevents surprises, enabling users to adapt and refactor their workflows accordingly.</li> <li>Security: Security changes focus on vulnerabilities that have been mitigated or resolved. This section reassures users that the project maintains high standards for safety and data protection.</li> </ul>"},{"location":"changelog/#v134-2025-01-07","title":"v1.3.4 - 2025-01-07","text":""},{"location":"changelog/#adds","title":"Adds","text":"<ul> <li>File docstrings for source code, documenting the file role</li> <li>File docstrings now observed and inserted into output documentation markdown</li> </ul>"},{"location":"changelog/#updates","title":"Updates","text":"<ul> <li>Mosheh now requires Python 3.13</li> <li>Dependencies now supports versions in <code>lib&gt;=x.x.x</code> style, no more <code>lib==x.x.x</code> only</li> <li><code>mosheh.doc</code> functions <code>__write_to_file</code> to <code>_write_to_file</code> and <code>__update_navigation</code> to <code>_update_navigation</code></li> </ul>"},{"location":"changelog/#fixes","title":"Fixes","text":"<ul> <li><code>'.'</code> added to generated documentation files and dirs on <code>mosheh.doc</code> creation lines</li> </ul>"},{"location":"changelog/#v133-2024-12-27","title":"v1.3.3 - 2024-12-27","text":""},{"location":"changelog/#adds_1","title":"Adds","text":"<ul> <li>\"Role\" defined and added to markdown generated doc files</li> <li>Functions now has docstring description on markdown</li> </ul>"},{"location":"changelog/#updates_1","title":"Updates","text":"<ul> <li>Codebase readed files now documented under <code>- Codebase</code> section on generated <code>mkdocs.yml</code></li> </ul>"},{"location":"changelog/#security","title":"Security","text":"<ul> <li><code>f'{name}'</code> to <code>f'{name}'</code> on <code>tests.PROJECT.dummy.views.index</code> test example</li> </ul>"},{"location":"changelog/#v132-2024-12-17","title":"v1.3.2 - 2024-12-17","text":""},{"location":"changelog/#adds_2","title":"Adds","text":"<ul> <li><code>_mark_methods</code> created on <code>mosheh.codebase</code> plus <code>encapsulated_mark_methods_for_unittest</code> for testing</li> <li>Examples for <code>mosheh.handler</code> functions on docstrings</li> </ul>"},{"location":"changelog/#updates_2","title":"Updates","text":"<ul> <li>Sequence-like <code>mosheh.constants</code> constants sorted in code to better performing</li> </ul>"},{"location":"changelog/#fixes_1","title":"Fixes","text":"<ul> <li>Implementing <code>rich</code> as direct dependency</li> </ul>"},{"location":"changelog/#v131-2024-12-16","title":"v1.3.1 - 2024-12-16","text":""},{"location":"changelog/#adds_3","title":"Adds","text":"<ul> <li>Publish official documentation website: https://lucasgoncsilva.github.io/mosheh/</li> </ul>"},{"location":"changelog/#updates_3","title":"Updates","text":"<ul> <li>Remaking the Mosheh's documentation itself</li> <li>Setting documentation website metadata on <code>pyproject.toml</code></li> <li><code>mosheh.constants</code> constants <code>BUILTIN_MODULES</code>, <code>BUILTIN_FUNCTIONS</code>, <code>BUILTIN_DUNDER_METHODS</code> and <code>ACCEPTABLE_LOWER_CONSTANTS</code> from <code>typing.Iterator</code> to <code>typing.Sequence</code></li> </ul>"},{"location":"changelog/#v130-2024-12-13","title":"v1.3.0 - 2024-12-13","text":""},{"location":"changelog/#adds_4","title":"Adds","text":"<ul> <li>Handler functions to deal with statements not defined before, such as <code>ast.For</code> - all below:</li> </ul> Added Nodes <code>ast.AsyncFor</code> <code>ast.AsyncWith</code> <code>ast.AugAssign</code> <code>ast.Await</code> <code>ast.Break</code> <code>ast.Continue</code> <code>ast.Del</code> <code>ast.Delete</code> <code>ast.ExceptHandler</code> <code>ast.Expr</code> <code>ast.For</code> <code>ast.FormattedValue</code> <code>ast.Global</code> <code>ast.If</code> <code>ast.Load</code> <code>ast.Match</code> <code>ast.NamedExpr</code> <code>ast.Nonlocal</code> <code>ast.ParamSpec</code> <code>ast.Pass</code> <code>ast.Raise</code> <code>ast.Return</code> <code>ast.Starred</code> <code>ast.Store</code> <code>ast.TryStar</code> <code>ast.Try</code> <code>ast.TypeAlias</code> <code>ast.TypeVarTuple</code> <code>ast.TypeVar</code> <code>ast.While</code> <code>ast.With</code> <code>ast.YieldFrom</code> <code>ast.Yield</code> <ul> <li><code>rtype</code> or return type notation on <code>tests.unittest</code> test functions</li> <li>New theme to Mosheh's self documentation code blocks inspired by Dracula Theme</li> <li>Insert logs on all the Mosheh's codebase using <code>mosheh.set_logging_config</code> and native <code>logging</code>:</li> <li>CRITICAL: when something crashes the script</li> <li>ERROR: non-crashing errors on the script</li> <li>WARNING: notorious advising that are not errors</li> <li>INFO: normal log level</li> <li>DEBUG: detailed step-by-step execution</li> </ul>"},{"location":"changelog/#updates_4","title":"Updates","text":"<ul> <li><code>mosheh.handler._handle_node</code> now can handle nodes off all types listed above</li> <li><code>ast.FunctionDef</code> inside of <code>ast.ClassDef</code> now with <code>FunctionType.Method</code> attribute on output doc</li> </ul>"},{"location":"changelog/#removes","title":"Removes","text":"<ul> <li><code>Statement</code> class from <code>mosheh.custom_types</code> unused types, such as <code>Statement.Call</code> - all below:</li> </ul> Removed Types <code>BinOp = auto()</code> <code>Call = auto()</code> <code>Compare = auto()</code> <code>List = auto()</code> <code>Set = auto()</code> <code>Tuple = auto()</code> <code>Dict = auto()</code> <code>Slice = auto()</code> <code>Subscript = auto()</code>"},{"location":"changelog/#v121-2024-12-10","title":"v1.2.1 - 2024-12-10","text":""},{"location":"changelog/#adds_5","title":"Adds","text":"<ul> <li>Unittest workflow for automated tests using <code>pytest</code>: <code>.github/workflows/unittest.yml</code></li> <li>PyPI publishing workflow for new public versions using <code>uv</code> and <code>twine</code>: <code>.github/workflows/publish_pypi.yml</code></li> <li>MkDocs publishing workflow for updating documentation using <code>uv</code> and <code>mkdocs</code>: <code>.github/workflows/publish_mkdocs.yml</code></li> <li>New badges for <code>README.md</code> \"Stack\" section: Material for MkDocs, GitHub, GitHub Pages and GitHub Actions</li> <li><code>[build-system]</code>, <code>[project.urls]</code>, <code>[project.scripts]</code> and some other small infos inserted on <code>pyproject.toml</code></li> </ul>"},{"location":"changelog/#updates_5","title":"Updates","text":"<ul> <li>Reordering Stack badges for <code>README.md</code></li> </ul>"},{"location":"changelog/#fixes_2","title":"Fixes","text":"<ul> <li><code>mosheh</code> back as script entrypoint for Mosheh in <code>pyproject.toml</code> config file</li> </ul>"},{"location":"changelog/#removes_1","title":"Removes","text":"<ul> <li><code>setup.py</code> deleted due total substitution by <code>pyproject.toml</code></li> </ul>"},{"location":"changelog/#v120-2024-12-10","title":"v1.2.0 - 2024-12-10","text":""},{"location":"changelog/#adds_6","title":"Adds","text":"<ul> <li>Test file for <code>mosheh.utils</code> functions: <code>tests.unittest.utils</code></li> <li>Test file for <code>mosheh.constants</code> constants: <code>tests.unittest.constants</code></li> <li>Test file for <code>mosheh.doc</code> functions: <code>tests.unittest.doc</code></li> <li>Test file for <code>mosheh.handler</code> functions: <code>tests.unittest.handler</code></li> <li>Mock test file <code>mock.py.txt</code> for serving <code>tests.unittest.handler</code> as template</li> </ul>"},{"location":"changelog/#updates_6","title":"Updates","text":"<ul> <li><code>pyproject.toml</code> setting <code>pytest</code> to use <code>-vv</code> parameter</li> <li><code>list[Any] | tuple[Any]</code> to <code>collections.abc.Sequence[Any]</code> on <code>mosheh.utils.bin:universe</code> arg</li> <li><code>dict[Any, Any]</code> to <code>defaultdict[Any, Any]</code> on <code>mosheh.utils.nested_dict</code> rtype</li> <li><code>dict[Any, Any]</code> to <code>defaultdict[Any, Any]</code> on <code>mosheh.utils.add_to_dict:structure</code> arg and rtype</li> <li>Changing all <code>moshe.doc</code> functions except <code>generate_doc</code> to be private (e.g. <code>_process_file</code>)</li> <li>Changing all <code>moshe.handlers</code> functions except <code>handle_def_nodes</code> to be private (e.g. <code>_process_file</code>)</li> <li>Renaming <code>moshe.handlers</code> to <code>moshe.handler</code></li> <li>Changing <code>moshe.codebase.iterate</code> to be private: <code>moshe.codebase._iterate</code></li> </ul>"},{"location":"changelog/#fixes_3","title":"Fixes","text":"<ul> <li><code>Proccess</code> word refined to <code>Process</code></li> </ul>"},{"location":"changelog/#v111-2024-12-06","title":"v1.1.1 - 2024-12-06","text":""},{"location":"changelog/#adds_7","title":"Adds","text":"<ul> <li><code>metadata.py</code> created to separate metadata from the actual <code>main.py</code> file</li> </ul>"},{"location":"changelog/#updates_7","title":"Updates","text":"<ul> <li>Migration from <code>pip</code>/<code>requirements.txt</code> dependency management to <code>uv</code>/<code>pyproject.toml</code>/<code>uv.lock</code>/<code>.python-version</code></li> <li><code>documentation/*.md</code> files formatted</li> <li><code>README.md</code> updated with new local installation and running instructions</li> <li><code>README.md</code> updated with new dependency management system into dir's demonstration</li> <li>Substituting <code>handlers.py</code>'s <code>typing.Optional</code> to <code>... | None</code> (e.g. <code>Optional[str]</code> to <code>str | None</code>)</li> </ul>"},{"location":"changelog/#removes_2","title":"Removes","text":"<ul> <li><code>ruff.toml</code> deleted due to <code>pyproject.toml</code> creation</li> </ul>"},{"location":"changelog/#v110-2024-12-06","title":"v1.1.0 - 2024-12-06","text":""},{"location":"changelog/#adds_8","title":"Adds","text":"<ul> <li>Creation of <code>CHANGELOG.md</code></li> <li><code>setup.py</code> into <code>README.md</code> dir's demonstration</li> <li><code>documentation</code> into <code>README.md</code> dir's demonstration</li> <li><code>--edit-uri</code> parameter defined as <code>'blob/main/documentation/docs'</code></li> </ul>"},{"location":"changelog/#updates_8","title":"Updates","text":"<ul> <li><code>README.md</code>'s todo list targets</li> <li><code>--exit</code> parameter renamed to <code>--output</code></li> <li><code>--logo-path</code> argument's defaults to <code>None</code></li> <li><code>--readme-path</code> argument's defaults to <code>None</code></li> <li><code>clickable_checkbox</code> statement of <code>mkdocs.yml</code> defaults to <code>false</code></li> <li>Some function docstrings reviewed</li> </ul>"},{"location":"changelog/#v100-2024-12-04","title":"v1.0.0 - 2024-12-04","text":""},{"location":"changelog/#adds_9","title":"Adds","text":"<ul> <li>First stable version release</li> </ul>"},{"location":"starting/","title":"Getting Starded","text":"<p>The Homepage already introduced Mosheh's usage in a nutshell and just by readind there you are already able to use it, but here we are going to cover it in details.</p>"},{"location":"starting/#installation","title":"Installation","text":"<p>To install Mosheh there is no secret, you can literally just tell your package manager to install <code>mosheh</code> and use it. As it has no production-like role, it's highly recommended to install as dev dependency, also saving as it as well.</p>"},{"location":"starting/#uv","title":"uv","text":"<p>An extremely fast Python package and project manager, uv is written in Rust and backed by Astral, the creators of Ruff. In a few words, uv has an ambitious proposal: use the power of Rust to replace <code>pip</code>, <code>pip-tools</code>, <code>pipx</code>, <code>poetry</code>, <code>pyenv</code>, <code>twine</code>, <code>virtualenv</code> and more dev tools like these. To install Mosheh with uv just use the command below:</p> Bash<pre><code>uv add mosheh --dev\n</code></pre> <p>By doing it, uv is going to save Mosheh as dev dependency on <code>pyproject.toml</code> with the structure below, where <code>x.x.x</code> is the last version released or the chosen one:</p> YAML<pre><code>[project]\nname = \"your-project\"\n...\n\n[dependency-groups]\ndev = [\"mosheh&gt;=x.x.x\"]\n</code></pre> <p>For more information about uv installation please check: https://docs.astral.sh/uv/</p> <p>Personal Recomendation</p> <p>uv is the personal recomendation for managing project dependencies and handling development tasks, such as building; check it out for your personal use case.</p>"},{"location":"starting/#pip","title":"PIP","text":"<p>The most commonly used tool for dependency management, PIP is frequently installed with the Python Interpreter. It has no command or parameter to install libs as development dependency, but there is a recommended solution to this: separate a production requirements file from a development one. To achieve this goal follow the steps below:</p> <ol> <li>Create a <code>requirements.dev.txt</code> or similar: <code>touch requirements.dev.txt</code></li> <li>Tell it to read main/production <code>requirements.txt</code>: <code>echo \"-r ./path/to/requirements.txt\" &gt; requirements.dev.txt</code></li> <li>Install Mosheh with common install command: <code>pip install mosheh</code></li> <li>Write Mosheh to the dev requirements file: <code>echo mosheh &gt;&gt; requirements.dev.txt</code></li> </ol> <p>The full logic ends like this:</p> Bash<pre><code>touch requirements.dev.txt\necho \"-r ./path/to/requirements.txt\" &gt; requirements.dev.txt\npip install mosheh\necho mosheh &gt;&gt; requirements.dev.txt\n</code></pre> <p>Example Path Above</p> <p>Just remember to update path to the real path on your case, just copying and pasting may not work because the used path is a mock one.</p>"},{"location":"starting/#poetry","title":"Poetry","text":"<p>Poetry is a tool for dependency management and packaging in Python. It allows you to declare the libraries your project depends on and it will manage (install/update) them for you. Poetry offers a lockfile to ensure repeatable installs, and can build your project for distribution. Just like uv, Poetry is better than PIP because of its robust features list, ensuring more possibilities to automate and handle development processes. To install Mosheh with Poetry you can run the command below:</p> Bash<pre><code>poetry add mosheh -G dev\n</code></pre> <p>Since <code>--dev</code> is now deprecated the documentation itself says to use <code>--group dev</code> <code>-G dev</code>. Being more specific you can also define Mosheh as documentation dependency, depending on how you wants to deal with it by running <code>poetry add mosheh -G docs</code>.</p>"},{"location":"starting/#execution","title":"Execution","text":"<p>As shown above, there are different ways to install Mosheh and the same happens when running it. In general cases calling <code>mosheh</code> on terminal already works, but depending on the installation method there are better options to execute the same script.</p> <p>If using PIP, the way demonstraded below is suficient:</p> Bash<pre><code>mosheh [-h] -root ROOT: Path \\\n      [--repo-name REPO_NAME: str] \\\n      [--repo-url REPO_URL: URL] \\\n      [--edit-uri EDIT_URI: str] \\\n      [--logo-path LOGO_PATH: Path] \\\n      [--readme-path README_PATH: Path] \\\n      [--verbose VERBOSE: Literal[0 | 1 | 2 | 3 | 4]] \\\n      [--output OUTPUT: Path]\n</code></pre> <p>Elif using uv, call <code>mosheh</code> from <code>uv run</code> to be concise with the ecosystem in use:</p> Bash<pre><code>uv run mosheh [-h] -root ROOT: Path \\\n      [--repo-name REPO_NAME: str] \\\n      [--repo-url REPO_URL: URL] \\\n      [--edit-uri EDIT_URI: str] \\\n      [--logo-path LOGO_PATH: Path] \\\n      [--readme-path README_PATH: Path] \\\n      [--verbose VERBOSE: Literal[0 | 1 | 2 | 3 | 4]] \\\n      [--output OUTPUT: Path]\n</code></pre> <p>Elif using another method installation, remenber to check if there is support for running scripts by them or you should use <code>mosheh</code> directly from terminal.</p>"},{"location":"starting/#parameters","title":"Parameters","text":"<p>The parameters for running Mosheh goes from the codebase root to the logging level. Here we are going to cover them in detail to be no doubt about the use of each one.</p>"},{"location":"starting/#-root","title":"<code>-root</code>","text":"<ul> <li>Mandatory: <code>Required</code></li> <li>Type: <code>Path</code></li> <li>Default: <code>None</code></li> </ul> <p>This represents the root dir, where Mosheh is going to start mining. To prevents it of search for files on a random directory or document undesired code, it's mandatory to tell where the search should start.</p>"},{"location":"starting/#-repo-name","title":"<code>--repo-name</code>","text":"<ul> <li>Mandatory: <code>Optional</code></li> <li>Type: <code>str</code></li> <li>Default: <code>'GitHub'</code></li> </ul> <p>This tells the repository name to be annotated in the generated documentation. Usually the used value is the repository username plus the project name, such as <code>reu/zerg</code> or <code>LucasGoncSilva/mosheh</code>.</p>"},{"location":"starting/#-repo-url","title":"<code>--repo-url</code>","text":"<ul> <li>Mandatory: <code>Optional</code></li> <li>Type: <code>URL</code></li> <li>Default: <code>'https://github.com/'</code></li> </ul> <p>As the name suggests, this one is for create the documentation with repo URL defined. Following the example above, it's value should be <code>https://github.com/reu/zerg</code> or <code>https://github.com/LucasGoncSilva/mosheh</code>.</p>"},{"location":"starting/#-edit-uri","title":"<code>--edit-uri</code>","text":"<ul> <li>Mandatory: <code>Optional</code></li> <li>Type: <code>str</code></li> <li>Default: <code>'blob/main/documentation/docs'</code></li> </ul> <p>When you visits someone's GitHub repository, the URL is the well known <code>https://github.com/reu/zerg</code>. Once you go to view/update it, the <code>--edit-uri</code> comes to it: <code>https://github.com/reu/zerg/blob/master/Cargo.toml</code>. Since this is configured to the main branch and the specific dir <code>documentation/docs</code>, any file on this sub-path will be allowed for view or edit if your ptoject desires that.</p>"},{"location":"starting/#-logo-path","title":"<code>--logo-path</code>","text":"<ul> <li>Mandatory: <code>Optional</code></li> <li>Type: <code>Path</code></li> <li>Default: <code>None</code></li> </ul> <p>There is no secret about this one. You passes the path to project's logo and Mosheh uses it as documentation logo. Just like this. If not provided, this will be using Material MkDocs one.</p>"},{"location":"starting/#-readme-path","title":"<code>--readme-path</code>","text":"<ul> <li>Mandatory: <code>Optional</code></li> <li>Type: <code>Path</code></li> <li>Default: <code>None</code></li> </ul> <p>There is also no secret about this one. You passes the path to project's <code>README.md</code> and Mosheh uses it as documentation Homepage. Just like this. If not provided, this wiil be using the default MkDocs index page content.</p>"},{"location":"starting/#-verbose","title":"<code>--verbose</code>","text":"<ul> <li>Mandatory: <code>Optional</code></li> <li>Type: <code>int</code></li> <li>Default: <code>3</code></li> </ul> <p>When running the script, may be util to see what's going on under the hoods... or not. For this case, <code>--verbose</code> comes to play allowing you to choose between different types of logging, from 0 to 4: <code>logging.CRITICAL</code>, <code>logging.ERROR</code>, <code>logging.WARNING</code>, <code>logging.INFO</code> and <code>logging.DEBUG</code>.</p>"},{"location":"starting/#-output","title":"<code>--output</code>","text":"<ul> <li>Mandatory: <code>Optional</code></li> <li>Type: <code>Path</code></li> <li>Default: <code>'.'</code></li> </ul> <p>Similar to <code>--root</code>, but for the generated documentation. The path provided here is the path to find the documentation at the end of the day. Not too much about this one.</p>"},{"location":"mosheh/","title":"Codebase","text":"<p>You are about to read about the Mosheh's codebase as it is defined by itself. Not every line or detail are covered here, specially files that doesn't contains any statement defined since this documentation Homepage.</p> <p>You can use the following file to check what Mosheh does in fact, plus study what files are included and how each file works: the imports, definitions and assertions. Just keep in mind the files flow demonstraded on the landing page:</p> <p></p>"},{"location":"mosheh/__init__.py/","title":"File: <code>__init__.py</code>","text":"<p>Role: Python Source Code</p> <p>Path: <code>mosheh</code></p> <p>No file docstring provided.</p>"},{"location":"mosheh/__init__.py/#imports","title":"Imports","text":"<p>NO IMPORT DEFINED HERE</p>"},{"location":"mosheh/__init__.py/#consts","title":"Consts","text":"<p>NO CONSTANT DEFINED HERE</p>"},{"location":"mosheh/__init__.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"mosheh/__init__.py/#functions","title":"Functions","text":"<p>NO FUNCTION DEFINED HERE</p>"},{"location":"mosheh/__init__.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"mosheh/codebase.py/","title":"File: <code>codebase.py</code>","text":"<p>Role: Python Source Code</p> <p>Path: <code>mosheh</code></p> <p>This module provides functionality to analyze a Python codebase, extracting and organizing its structural information.</p> <p>The primary purpose of this module is to traverse a directory tree, identify Python source files, and parse their abstract syntax trees (AST) to collect metadata about their classes, functions, and methods. The gathered data is organized in a nested dictionary format (<code>CodebaseDict</code>) to facilitate further processing and analysis.</p> <p>Key Functions:</p> <ul> <li> <p><code>read_codebase</code>: Orchestrates the entire process by iterating through the codebase,   parsing Python files, and storing structured information about their contents.</p> </li> <li> <p><code>_mark_methods</code>: Annotates methods in class definitions with a <code>parent</code> attribute to   link them back to their parent class.</p> </li> <li> <p><code>encapsulated_mark_methods_for_unittest</code>: Exposes <code>_mark_methods</code> for external testing   purposes.</p> </li> <li> <p><code>_iterate</code>: Recursively yields file paths within the provided root directory for   iteration.</p> </li> </ul> <p>How It Works:</p> <ol> <li> <p>The <code>read_codebase</code> function starts by invoking <code>_iterate</code> to traverse the directory    tree starting from the given root path.</p> </li> <li> <p>For each Python file encountered, the file is read, and its AST is parsed to extract    relevant information.</p> </li> <li> <p>The <code>_mark_methods</code> function adds parent annotations to methods inside class    definitions to establish context.</p> </li> <li> <p>The extracted data is processed using the <code>handle_def_nodes</code> function and added to    the nested dictionary structure using utilities like <code>add_to_dict</code>.</p> </li> <li> <p>The result is a comprehensive dictionary (<code>CodebaseDict</code>) containing all collected    data, which is returned as a standard dictionary for compatibility.</p> </li> </ol> <p>This module is a foundational component for automated documentation generation, providing the structural insights needed for subsequent steps in the documentation pipeline.</p>"},{"location":"mosheh/codebase.py/#imports","title":"Imports","text":""},{"location":"mosheh/codebase.py/#import-ast","title":"<code>import ast</code>","text":"<p>Path: <code>None</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>import ast\n</code></pre>"},{"location":"mosheh/codebase.py/#import-generator","title":"<code>import Generator</code>","text":"<p>Path: <code>collections.abc</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from collections.abc import Generator\n</code></pre>"},{"location":"mosheh/codebase.py/#import-logger","title":"<code>import Logger</code>","text":"<p>Path: <code>logging</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from logging import Logger\n</code></pre>"},{"location":"mosheh/codebase.py/#import-getlogger","title":"<code>import getLogger</code>","text":"<p>Path: <code>logging</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from logging import getLogger\n</code></pre>"},{"location":"mosheh/codebase.py/#import-path","title":"<code>import path</code>","text":"<p>Path: <code>os</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from os import path\n</code></pre>"},{"location":"mosheh/codebase.py/#import-sep","title":"<code>import sep</code>","text":"<p>Path: <code>os</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from os import sep\n</code></pre>"},{"location":"mosheh/codebase.py/#import-walk","title":"<code>import walk</code>","text":"<p>Path: <code>os</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from os import walk\n</code></pre>"},{"location":"mosheh/codebase.py/#import-any","title":"<code>import Any</code>","text":"<p>Path: <code>typing</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from typing import Any\n</code></pre>"},{"location":"mosheh/codebase.py/#import-codebasedict","title":"<code>import CodebaseDict</code>","text":"<p>Path: <code>custom_types</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from custom_types import CodebaseDict\n</code></pre>"},{"location":"mosheh/codebase.py/#import-filerole","title":"<code>import FileRole</code>","text":"<p>Path: <code>custom_types</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from custom_types import FileRole\n</code></pre>"},{"location":"mosheh/codebase.py/#import-standardreturn","title":"<code>import StandardReturn</code>","text":"<p>Path: <code>custom_types</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from custom_types import StandardReturn\n</code></pre>"},{"location":"mosheh/codebase.py/#import-handle_def_nodes","title":"<code>import handle_def_nodes</code>","text":"<p>Path: <code>handler</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from handler import handle_def_nodes\n</code></pre>"},{"location":"mosheh/codebase.py/#import-add_to_dict","title":"<code>import add_to_dict</code>","text":"<p>Path: <code>utils</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from utils import add_to_dict\n</code></pre>"},{"location":"mosheh/codebase.py/#import-convert_to_regular_dict","title":"<code>import convert_to_regular_dict</code>","text":"<p>Path: <code>utils</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from utils import convert_to_regular_dict\n</code></pre>"},{"location":"mosheh/codebase.py/#import-nested_dict","title":"<code>import nested_dict</code>","text":"<p>Path: <code>utils</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from utils import nested_dict\n</code></pre>"},{"location":"mosheh/codebase.py/#consts","title":"Consts","text":"<p>NO CONSTANT DEFINED HERE</p>"},{"location":"mosheh/codebase.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"mosheh/codebase.py/#functions","title":"Functions","text":""},{"location":"mosheh/codebase.py/#def-read_codebase","title":"<code>def read_codebase</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>CodebaseDict</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>root: str</code></p> <p>Kwargs: <code>None</code></p> <p>Iterates through the codebase and collects all info needed.</p> <p>Using <code>iterate()</code> to navigate and <code>handle_def_nodes()</code> to get data, stores the collected data in a dict of type CodebaseDict, defined in constants.py file.</p> <p>Also works as a dispatch-like, matching the files extensions, leading each file to its flow.</p> <p>:param root: The root path/dir to be iterated.</p> <p>:type root: str</p> <p>:return: All the codebase data collected.</p> <p>:rtype: CodebaseDict</p> SNIPPET Python<pre><code>def read_codebase(root: str) -&gt; CodebaseDict:\n    \"\"\"\n    Iterates through the codebase and collects all info needed.\n\n    Using `iterate()` to navigate and `handle_def_nodes()` to get data,\n    stores the collected data in a dict of type CodebaseDict, defined\n    in constants.py file.\n\n    Also works as a dispatch-like, matching the files extensions,\n    leading each file to its flow.\n\n    :param root: The root path/dir to be iterated.\n    :type root: str\n    :return: All the codebase data collected.\n    :rtype: CodebaseDict\n    \"\"\"\n    codebase: CodebaseDict = nested_dict()\n    logger.info(f'Starting iteration through {root}')\n    for file in _iterate(root):\n        logger.debug(f'Iterating: {file}')\n        if file.endswith('.py'):\n            logger.debug(f'.py: {file}')\n            with open(file, encoding='utf-8') as f:\n                code: str = f.read()\n                logger.debug(f'{file} read')\n            tree: ast.AST = ast.parse(code, filename=file)\n            logger.debug('Code tree parsed')\n            statements: list[StandardReturn] = []\n            __meta__: StandardReturn = {'__role__': FileRole.PythonSourceCode, '__docstring__': 'No file docstring provided.'}\n            for node in ast.walk(tree):\n                logger.debug(f'Node: {type(node)}')\n                if isinstance(node, ast.Module) and (__docstring__ := ast.get_docstring(node)):\n                    __meta__['__docstring__'] = __docstring__\n                elif isinstance(node, ast.ClassDef):\n                    _mark_methods(node)\n                elif isinstance(node, ast.FunctionDef) and getattr(node, 'parent', None):\n                    continue\n                data: list[StandardReturn] = handle_def_nodes(node)\n                logger.debug('Node processed')\n                if data:\n                    statements.extend(data)\n                    logger.debug('Node inserted into statement list')\n            statements.insert(0, __meta__)\n            add_to_dict(codebase, file.split(sep), statements)\n            logger.debug(f'{file} stmts added to CodebaseDict')\n    return convert_to_regular_dict(codebase)\n</code></pre>"},{"location":"mosheh/codebase.py/#def-_mark_methods","title":"<code>def _mark_methods</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>None</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>node: ast.ClassDef</code></p> <p>Kwargs: <code>None</code></p> <p>Marks all <code>FunctionDef</code> nodes within a given <code>ClassDef</code> node by setting a <code>parent</code> attribute to indicate their association with the class.</p> <p>This function iterates over the child nodes of the provided class node, and for each method (a <code>FunctionDef</code>), it assigns the class type (<code>ast.ClassDef</code>) to the <code>parent</code> attribute of the method node.</p> <p>:param node: The class definition node containing methods to be marked.</p> <p>:type node: ast.ClassDef</p> <p>:return: No data to be returned</p> <p>:rtype: None</p> SNIPPET Python<pre><code>def _mark_methods(node: ast.ClassDef) -&gt; None:\n    \"\"\"\n    Marks all `FunctionDef` nodes within a given `ClassDef` node by setting a\n    `parent` attribute to indicate their association with the class.\n\n    This function iterates over the child nodes of the provided class node, and\n    for each method (a `FunctionDef`), it assigns the class type (`ast.ClassDef`)\n    to the `parent` attribute of the method node.\n\n    :param node: The class definition node containing methods to be marked.\n    :type node: ast.ClassDef\n    :return: No data to be returned\n    :rtype: None\n    \"\"\"\n    for child_node in ast.iter_child_nodes(node):\n        if isinstance(child_node, ast.FunctionDef):\n            setattr(child_node, 'parent', ast.ClassDef)\n</code></pre>"},{"location":"mosheh/codebase.py/#def-encapsulated_mark_methods_for_unittest","title":"<code>def encapsulated_mark_methods_for_unittest</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>None</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>node: ast.ClassDef</code></p> <p>Kwargs: <code>None</code></p> <p>Just encapsulates <code>_mark_methods</code> function to external use, only for unittesting.</p> <p>:param node: The class definition node containing methods to be marked.</p> <p>:type node: ast.ClassDef</p> <p>:return: No data to be returned</p> <p>:rtype: None</p> SNIPPET Python<pre><code>def encapsulated_mark_methods_for_unittest(node: ast.ClassDef) -&gt; None:\n    \"\"\"\n    Just encapsulates `_mark_methods` function to external use, only for unittesting.\n\n    :param node: The class definition node containing methods to be marked.\n    :type node: ast.ClassDef\n    :return: No data to be returned\n    :rtype: None\n    \"\"\"\n    _mark_methods(node)\n</code></pre>"},{"location":"mosheh/codebase.py/#def-_iterate","title":"<code>def _iterate</code>","text":"<p>Type: <code>Generator</code></p> <p>Return Type: <code>Generator[str, Any, Any]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>root: str</code></p> <p>Kwargs: <code>None</code></p> <p>Iterates through every dir and file starting at provided root.</p> <p>Iterates using for-loop in os.walk and for dirpath and file in files yields the path for each file from the provided root to it.</p> <p>:param root: The root to be used as basedir.</p> <p>:type root: str</p> <p>:return: The path for each file on for-loop.</p> <p>:rtype: Generator[str, Any, Any]</p> SNIPPET Python<pre><code>def _iterate(root: str) -&gt; Generator[str, Any, Any]:\n    \"\"\"\n    Iterates through every dir and file starting at provided root.\n\n    Iterates using for-loop in os.walk and for dirpath and file in\n    files yields the path for each file from the provided root to it.\n\n    :param root: The root to be used as basedir.\n    :type root: str\n    :return: The path for each file on for-loop.\n    :rtype: Generator[str, Any, Any]\n    \"\"\"\n    for dirpath, _, files in walk(root):\n        for file in files:\n            yield path.join(dirpath, file)\n</code></pre>"},{"location":"mosheh/codebase.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"mosheh/constants.py/","title":"File: <code>constants.py</code>","text":"<p>Role: Python Source Code</p> <p>Path: <code>mosheh</code></p> <p>This module defines constants and templates used throughout the project.</p> <p>It aims to standardize project-wide values, ensure consistency, and streamline the development and documentation process.</p> <p>The constants defined here are:</p> <ol> <li> <p><code>BUILTIN_MODULES</code>: A comprehensive list of Python's built-in modules for reference or    validation purposes.</p> </li> <li> <p><code>BUILTIN_FUNCTIONS</code>: A list of Python's built-in functions to support validation,    documentation or tooling needs.</p> </li> <li> <p><code>BUILTIN_DUNDER_METHODS</code>: Commonly used double-underscore (dunder) methods in Python,    aiding in validation or documentation.</p> </li> <li> <p><code>ACCEPTABLE_LOWER_CONSTANTS</code>: Lowercase constants acceptable in the project to    enforce naming conventions.</p> </li> <li> <p><code>DEFAULT_MKDOCS_YML</code>: A template for MkDocs configuration using the Material theme,    with custom settings for a consistent and professional documentation structure.</p> </li> <li> <p>Markdown Templates:</p> </li> <li>Files (<code>FILE_MARKDOWN</code>)</li> <li>Imports (<code>IMPORT_MD_STRUCT</code>)</li> <li>Assignments (<code>ASSIGN_MD_STRUCT</code>)</li> <li>Classes (<code>CLASS_DEF_MD_STRUCT</code>)</li> <li>Functions (<code>FUNCTION_DEF_MD_STRUCT</code>)</li> <li>Assertions (<code>ASSERT_MD_STRUCT</code>)</li> </ol> <p>These constants can be imported and reused wherever needed in the project. Be careful when updating this file to maintain consistency across the project. Remember that this file should remain immutable during runtime and utilize Python's <code>typing.Final</code> type hint to mark constants as non-overridable.</p>"},{"location":"mosheh/constants.py/#imports","title":"Imports","text":""},{"location":"mosheh/constants.py/#import-final","title":"<code>import Final</code>","text":"<p>Path: <code>typing</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from typing import Final\n</code></pre>"},{"location":"mosheh/constants.py/#consts","title":"Consts","text":""},{"location":"mosheh/constants.py/#builtin_modules","title":"<code>BUILTIN_MODULES</code>","text":"<p>Type: <code>Final[list[str]]</code></p> <p>Value: <code>['__future__', '_abc', '_aix_support', '_ast', '_asyncio', '_bisect', '_blake2', '_bootsubprocess', '_bz2', '_codecs', '_codecs_cn', '_codecs_hk', '_codecs_iso2022', '_codecs_jp', '_codecs_kr', '_codecs_tw', '_collections', '_collections_abc', '_compat_pickle', '_compression', '_contextvars', '_crypt', '_csv', '_ctypes', '_ctypes_test', '_curses', '_curses_panel', '_datetime', '_dbm', '_decimal', '_distutils_hack', '_distutils_system_mod', '_elementtree', '_functools', '_gdbm', '_hashlib', '_heapq', '_imp', '_io', '_json', '_locale', '_lsprof', '_lzma', '_markupbase', '_md5', '_multibytecodec', '_multiprocessing', '_opcode', '_operator', '_osx_support', '_pickle', '_posixshmem', '_posixsubprocess', '_py_abc', '_pydecimal', '_pyio', '_queue', '_random', '_sha1', '_sha256', '_sha3', '_sha512', '_signal', '_sitebuiltins', '_socket', '_sqlite3', '_sre', '_ssl', '_stat', '_statistics', '_string', '_strptime', '_struct', '_symtable', '_sysconfigdata__linux_x86_64-linux-gnu', '_sysconfigdata__x86_64-linux-gnu', '_testbuffer', '_testcapi', '_testclinic', '_testimportmultiple', '_testinternalcapi', '_testmultiphase', '_thread', '_threading_local', '_tracemalloc', '_uuid', '_warnings', '_weakref', '_weakrefset', '_xxsubinterpreters', '_xxtestfuzz', '_zoneinfo', 'abc', 'aifc', 'antigravity', 'argparse', 'array', 'ast', 'asynchat', 'asyncio', 'asyncore', 'atexit', 'audioop', 'base64', 'bdb', 'binascii', 'binhex', 'bisect', 'builtins', 'bz2', 'cProfile', 'calendar', 'cgi', 'cgitb', 'chunk', 'cmath', 'cmd', 'code', 'codecs', 'codeop', 'collections', 'colorsys', 'compileall', 'concurrent', 'configparser', 'contextlib', 'contextvars', 'copy', 'copyreg', 'crypt', 'csv', 'ctypes', 'curses', 'dataclasses', 'datetime', 'dbm', 'decimal', 'difflib', 'dis', 'distutils', 'doctest', 'email', 'encodings', 'ensurepip', 'enum', 'errno', 'faulthandler', 'fcntl', 'filecmp', 'fileinput', 'fnmatch', 'fractions', 'ftplib', 'functools', 'gc', 'genericpath', 'getopt', 'getpass', 'gettext', 'glob', 'graphlib', 'grp', 'gzip', 'hashlib', 'heapq', 'hmac', 'html', 'http', 'imaplib', 'imghdr', 'imp', 'importlib', 'inspect', 'io', 'ipaddress', 'itertools', 'json', 'keyword', 'lib2to3', 'linecache', 'locale', 'logging', 'lzma', 'mailbox', 'mailcap', 'marshal', 'math', 'mimetypes', 'mmap', 'modulefinder', 'multiprocessing', 'netrc', 'nis', 'nntplib', 'ntpath', 'nturl2path', 'numbers', 'opcode', 'operator', 'optparse', 'os', 'ossaudiodev', 'pathlib', 'pdb', 'pickle', 'pickletools', 'pip', 'pipes', 'pkg_resources', 'pkgutil', 'platform', 'plistlib', 'poplib', 'posix', 'posixpath', 'pprint', 'profile', 'pstats', 'pty', 'pwd', 'py_compile', 'pyclbr', 'pydoc', 'pydoc_data', 'pyexpat', 'queue', 'quopri', 'random', 're', 'readline', 'reprlib', 'resource', 'rlcompleter', 'runpy', 'sched', 'secrets', 'select', 'selectors', 'setuptools', 'shelve', 'shlex', 'shutil', 'signal', 'site', 'sitecustomize', 'smtpd', 'smtplib', 'sndhdr', 'socket', 'socketserver', 'spwd', 'sqlite3', 'sre_compile', 'sre_constants', 'sre_parse', 'ssl', 'stat', 'statistics', 'string', 'stringprep', 'struct', 'subprocess', 'sunau', 'symtable', 'sys', 'sysconfig', 'syslog', 'tabnanny', 'tarfile', 'telnetlib', 'tempfile', 'termios', 'test', 'textwrap', 'this', 'threading', 'time', 'timeit', 'token', 'tokenize', 'trace', 'traceback', 'tracemalloc', 'tty', 'turtle', 'types', 'typing', 'unicodedata', 'unittest', 'urllib', 'uu', 'uuid', 'venv', 'warnings', 'wave', 'weakref', 'webbrowser', 'wsgiref', 'xdrlib', 'xml', 'xmlrpc', 'xpto', 'xxlimited', 'xxlimited_35', 'xxsubtype', 'zipapp', 'zipfile', 'zipimport', 'zlib', 'zoneinfo']</code></p> SNIPPET Python<pre><code>BUILTIN_MODULES: Final[list[str]] = ['__future__', '_abc', '_aix_support', '_ast', '_asyncio', '_bisect', '_blake2', '_bootsubprocess', '_bz2', '_codecs', '_codecs_cn', '_codecs_hk', '_codecs_iso2022', '_codecs_jp', '_codecs_kr', '_codecs_tw', '_collections', '_collections_abc', '_compat_pickle', '_compression', '_contextvars', '_crypt', '_csv', '_ctypes', '_ctypes_test', '_curses', '_curses_panel', '_datetime', '_dbm', '_decimal', '_distutils_hack', '_distutils_system_mod', '_elementtree', '_functools', '_gdbm', '_hashlib', '_heapq', '_imp', '_io', '_json', '_locale', '_lsprof', '_lzma', '_markupbase', '_md5', '_multibytecodec', '_multiprocessing', '_opcode', '_operator', '_osx_support', '_pickle', '_posixshmem', '_posixsubprocess', '_py_abc', '_pydecimal', '_pyio', '_queue', '_random', '_sha1', '_sha256', '_sha3', '_sha512', '_signal', '_sitebuiltins', '_socket', '_sqlite3', '_sre', '_ssl', '_stat', '_statistics', '_string', '_strptime', '_struct', '_symtable', '_sysconfigdata__linux_x86_64-linux-gnu', '_sysconfigdata__x86_64-linux-gnu', '_testbuffer', '_testcapi', '_testclinic', '_testimportmultiple', '_testinternalcapi', '_testmultiphase', '_thread', '_threading_local', '_tracemalloc', '_uuid', '_warnings', '_weakref', '_weakrefset', '_xxsubinterpreters', '_xxtestfuzz', '_zoneinfo', 'abc', 'aifc', 'antigravity', 'argparse', 'array', 'ast', 'asynchat', 'asyncio', 'asyncore', 'atexit', 'audioop', 'base64', 'bdb', 'binascii', 'binhex', 'bisect', 'builtins', 'bz2', 'cProfile', 'calendar', 'cgi', 'cgitb', 'chunk', 'cmath', 'cmd', 'code', 'codecs', 'codeop', 'collections', 'colorsys', 'compileall', 'concurrent', 'configparser', 'contextlib', 'contextvars', 'copy', 'copyreg', 'crypt', 'csv', 'ctypes', 'curses', 'dataclasses', 'datetime', 'dbm', 'decimal', 'difflib', 'dis', 'distutils', 'doctest', 'email', 'encodings', 'ensurepip', 'enum', 'errno', 'faulthandler', 'fcntl', 'filecmp', 'fileinput', 'fnmatch', 'fractions', 'ftplib', 'functools', 'gc', 'genericpath', 'getopt', 'getpass', 'gettext', 'glob', 'graphlib', 'grp', 'gzip', 'hashlib', 'heapq', 'hmac', 'html', 'http', 'imaplib', 'imghdr', 'imp', 'importlib', 'inspect', 'io', 'ipaddress', 'itertools', 'json', 'keyword', 'lib2to3', 'linecache', 'locale', 'logging', 'lzma', 'mailbox', 'mailcap', 'marshal', 'math', 'mimetypes', 'mmap', 'modulefinder', 'multiprocessing', 'netrc', 'nis', 'nntplib', 'ntpath', 'nturl2path', 'numbers', 'opcode', 'operator', 'optparse', 'os', 'ossaudiodev', 'pathlib', 'pdb', 'pickle', 'pickletools', 'pip', 'pipes', 'pkg_resources', 'pkgutil', 'platform', 'plistlib', 'poplib', 'posix', 'posixpath', 'pprint', 'profile', 'pstats', 'pty', 'pwd', 'py_compile', 'pyclbr', 'pydoc', 'pydoc_data', 'pyexpat', 'queue', 'quopri', 'random', 're', 'readline', 'reprlib', 'resource', 'rlcompleter', 'runpy', 'sched', 'secrets', 'select', 'selectors', 'setuptools', 'shelve', 'shlex', 'shutil', 'signal', 'site', 'sitecustomize', 'smtpd', 'smtplib', 'sndhdr', 'socket', 'socketserver', 'spwd', 'sqlite3', 'sre_compile', 'sre_constants', 'sre_parse', 'ssl', 'stat', 'statistics', 'string', 'stringprep', 'struct', 'subprocess', 'sunau', 'symtable', 'sys', 'sysconfig', 'syslog', 'tabnanny', 'tarfile', 'telnetlib', 'tempfile', 'termios', 'test', 'textwrap', 'this', 'threading', 'time', 'timeit', 'token', 'tokenize', 'trace', 'traceback', 'tracemalloc', 'tty', 'turtle', 'types', 'typing', 'unicodedata', 'unittest', 'urllib', 'uu', 'uuid', 'venv', 'warnings', 'wave', 'weakref', 'webbrowser', 'wsgiref', 'xdrlib', 'xml', 'xmlrpc', 'xpto', 'xxlimited', 'xxlimited_35', 'xxsubtype', 'zipapp', 'zipfile', 'zipimport', 'zlib', 'zoneinfo']\n</code></pre>"},{"location":"mosheh/constants.py/#builtin_functions","title":"<code>BUILTIN_FUNCTIONS</code>","text":"<p>Type: <code>Final[list[str]]</code></p> <p>Value: <code>['abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']</code></p> SNIPPET Python<pre><code>BUILTIN_FUNCTIONS: Final[list[str]] = ['abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']\n</code></pre>"},{"location":"mosheh/constants.py/#builtin_dunder_methods","title":"<code>BUILTIN_DUNDER_METHODS</code>","text":"<p>Type: <code>Final[list[str]]</code></p> <p>Value: <code>['__abs__', '__add__', '__aenter__', '__aexit__', '__aiter__', '__and__', '__anext__', '__await__', '__bool__', '__bytes__', '__call__', '__ceil__', '__class_getitem__', '__complex__', '__contains__', '__del__', '__delattr__', '__delete__', '__delitem__', '__dir__', '__divmod__', '__enter__', '__eq__', '__exit__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__get__', '__getattr__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__index__', '__init__', '__init_subclass__', '__instancecheck__', '__int__', '__invert__', '__iter__', '__le__', '__len__', '__length_hint__', '__lshift__', '__lt__', '__matmul__', '__missing__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__repr__', '__reversed__', '__round__', '__rshift__', '__set__', '__set_name__', '__setattr__', '__setitem__', '__str__', '__sub__', '__subclasscheck__', '__truediv__', '__trunc__', '__xor__']</code></p> SNIPPET Python<pre><code>BUILTIN_DUNDER_METHODS: Final[list[str]] = ['__abs__', '__add__', '__aenter__', '__aexit__', '__aiter__', '__and__', '__anext__', '__await__', '__bool__', '__bytes__', '__call__', '__ceil__', '__class_getitem__', '__complex__', '__contains__', '__del__', '__delattr__', '__delete__', '__delitem__', '__dir__', '__divmod__', '__enter__', '__eq__', '__exit__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__get__', '__getattr__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__index__', '__init__', '__init_subclass__', '__instancecheck__', '__int__', '__invert__', '__iter__', '__le__', '__len__', '__length_hint__', '__lshift__', '__lt__', '__matmul__', '__missing__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__repr__', '__reversed__', '__round__', '__rshift__', '__set__', '__set_name__', '__setattr__', '__setitem__', '__str__', '__sub__', '__subclasscheck__', '__truediv__', '__trunc__', '__xor__']\n</code></pre>"},{"location":"mosheh/constants.py/#acceptable_lower_constants","title":"<code>ACCEPTABLE_LOWER_CONSTANTS</code>","text":"<p>Type: <code>Final[list[str]]</code></p> <p>Value: <code>['__author__', '__copyright__', '__credits__', '__date__', '__email__', '__keywords__', '__license__', '__maintainer__', '__repository__', '__status__', '__version__', 'app', 'app_name', 'application', 'main', 'urlpatterns']</code></p> SNIPPET Python<pre><code>ACCEPTABLE_LOWER_CONSTANTS: Final[list[str]] = ['__author__', '__copyright__', '__credits__', '__date__', '__email__', '__keywords__', '__license__', '__maintainer__', '__repository__', '__status__', '__version__', 'app', 'app_name', 'application', 'main', 'urlpatterns']\n</code></pre>"},{"location":"mosheh/constants.py/#default_mkdocs_yml","title":"<code>DEFAULT_MKDOCS_YML</code>","text":"<p>Type: <code>Final[str]</code></p> <p>Value: <code>'site_name: {proj_name}\\nrepo_url: {repo_url}\\nrepo_name: {repo_name}\\nedit_uri: \"{edit_uri}\"\\n\\n\\ntheme:\\n  name: material\\n  language: en\\n  favicon: {logo_path}\\n  logo: {logo_path}\\n  font:\\n    text: Ubuntu\\n\\n  icon:\\n    tag:\\n      homepage: fontawesome/solid/house\\n      index: fontawesome/solid/file\\n      overview: fontawesome/solid/binoculars\\n      test: fontawesome/solid/flask-vial\\n      infra: fontawesome/solid/server\\n      doc: fontawesome/solid/book\\n      legal: fontawesome/solid/scale-unbalanced\\n      user: fontawesome/solid/user\\n      API: fontawesome/solid/gears\\n      browser: fontawesome/solid/desktop\\n\\n    next: fontawesome/solid/arrow-right\\n    previous: fontawesome/solid/arrow-left\\n    top: fontawesome/solid/arrow-up\\n    repo: fontawesome/brands/git-alt\\n    edit: material/pencil\\n    view: material/eye\\n    admonition:\\n      note: fontawesome/solid/note-sticky\\n      abstract: fontawesome/solid/book\\n      info: fontawesome/solid/circle-info\\n      tip: fontawesome/solid/fire-flame-simple\\n      success: fontawesome/solid/check\\n      question: fontawesome/solid/circle-question\\n      warning: fontawesome/solid/triangle-exclamation\\n      failure: fontawesome/solid/xmark\\n      danger: fontawesome/solid/skull\\n      bug: fontawesome/solid/bug\\n      example: fontawesome/solid/flask\\n      quote: fontawesome/solid/quote-left\\n\\n  palette:\\n    # Palette toggle for light mode\\n    - scheme: default\\n      toggle:\\n        icon: material/brightness-7\\n        name: Light/Dark Mode\\n      primary: green\\n      accent: indigo\\n\\n    # Palette toggle for dark mode\\n    - scheme: slate\\n      toggle:\\n        icon: material/brightness-3\\n        name: Light/Dark Mode\\n      primary: teal\\n      accent: orange\\n\\n\\n  features:\\n    - navigation.indexes\\n    - navigation.tabs\\n    - navigation.top\\n    - toc.integrate\\n    - header.autohide\\n    - navigation.footer\\n    - content.action.view\\n    - content.action.edit\\n    - announce.dismiss\\n    - content.tabs.link\\n\\n\\nmarkdown_extensions:\\n  - attr_list\\n  - pymdownx.emoji:\\n      emoji_index: !!python/name:material.extensions.emoji.twemoji\\n      emoji_generator: !!python/name:material.extensions.emoji.to_svg\\n  - pymdownx.highlight:\\n      anchor_linenums: true\\n      use_pygments: true\\n      pygments_lang_class: true\\n      auto_title: true\\n      linenums: true\\n  - pymdownx.inlinehilite\\n  - pymdownx.snippets\\n  - pymdownx.superfences:\\n      custom_fences:\\n        - name: mermaid\\n          class: mermaid\\n          format: !!python/name:pymdownx.superfences.fence_code_format\\n  - admonition\\n  - pymdownx.details\\n  - attr_list\\n  - md_in_html\\n  - pymdownx.tabbed:\\n      alternate_style: true\\n  - pymdownx.arithmatex:\\n      generic: true\\n  - def_list\\n  - pymdownx.tasklist:\\n      custom_checkbox: true\\n      clickable_checkbox: false\\n\\n\\nplugins:\\n  - search\\n  - tags\\n  - git-revision-date-localized:\\n      enable_creation_date: true\\n      type: datetime\\n      enabled: true\\n      enable_creation_date: true\\n      fallback_to_build_date: true\\n      locale: en\\n\\n\\nextra:\\n  tags:\\n    Homepage: homepage\\n    Index: index\\n    Overview: overview\\n    Test: test\\n    Infra: infra\\n    Documentation: doc\\n    Legal: legal\\n    Usu\u00e1rio: user\\n    API: API\\n    Browser: browser\\n\\n  status:\\n    new: Recently Added!\\n\\n\\ncopyright: Only God knows\\n\\n\\n'</code></p> SNIPPET Python<pre><code>DEFAULT_MKDOCS_YML: Final[str] = 'site_name: {proj_name}\\nrepo_url: {repo_url}\\nrepo_name: {repo_name}\\nedit_uri: \"{edit_uri}\"\\n\\n\\ntheme:\\n  name: material\\n  language: en\\n  favicon: {logo_path}\\n  logo: {logo_path}\\n  font:\\n    text: Ubuntu\\n\\n  icon:\\n    tag:\\n      homepage: fontawesome/solid/house\\n      index: fontawesome/solid/file\\n      overview: fontawesome/solid/binoculars\\n      test: fontawesome/solid/flask-vial\\n      infra: fontawesome/solid/server\\n      doc: fontawesome/solid/book\\n      legal: fontawesome/solid/scale-unbalanced\\n      user: fontawesome/solid/user\\n      API: fontawesome/solid/gears\\n      browser: fontawesome/solid/desktop\\n\\n    next: fontawesome/solid/arrow-right\\n    previous: fontawesome/solid/arrow-left\\n    top: fontawesome/solid/arrow-up\\n    repo: fontawesome/brands/git-alt\\n    edit: material/pencil\\n    view: material/eye\\n    admonition:\\n      note: fontawesome/solid/note-sticky\\n      abstract: fontawesome/solid/book\\n      info: fontawesome/solid/circle-info\\n      tip: fontawesome/solid/fire-flame-simple\\n      success: fontawesome/solid/check\\n      question: fontawesome/solid/circle-question\\n      warning: fontawesome/solid/triangle-exclamation\\n      failure: fontawesome/solid/xmark\\n      danger: fontawesome/solid/skull\\n      bug: fontawesome/solid/bug\\n      example: fontawesome/solid/flask\\n      quote: fontawesome/solid/quote-left\\n\\n  palette:\\n    # Palette toggle for light mode\\n    - scheme: default\\n      toggle:\\n        icon: material/brightness-7\\n        name: Light/Dark Mode\\n      primary: green\\n      accent: indigo\\n\\n    # Palette toggle for dark mode\\n    - scheme: slate\\n      toggle:\\n        icon: material/brightness-3\\n        name: Light/Dark Mode\\n      primary: teal\\n      accent: orange\\n\\n\\n  features:\\n    - navigation.indexes\\n    - navigation.tabs\\n    - navigation.top\\n    - toc.integrate\\n    - header.autohide\\n    - navigation.footer\\n    - content.action.view\\n    - content.action.edit\\n    - announce.dismiss\\n    - content.tabs.link\\n\\n\\nmarkdown_extensions:\\n  - attr_list\\n  - pymdownx.emoji:\\n      emoji_index: !!python/name:material.extensions.emoji.twemoji\\n      emoji_generator: !!python/name:material.extensions.emoji.to_svg\\n  - pymdownx.highlight:\\n      anchor_linenums: true\\n      use_pygments: true\\n      pygments_lang_class: true\\n      auto_title: true\\n      linenums: true\\n  - pymdownx.inlinehilite\\n  - pymdownx.snippets\\n  - pymdownx.superfences:\\n      custom_fences:\\n        - name: mermaid\\n          class: mermaid\\n          format: !!python/name:pymdownx.superfences.fence_code_format\\n  - admonition\\n  - pymdownx.details\\n  - attr_list\\n  - md_in_html\\n  - pymdownx.tabbed:\\n      alternate_style: true\\n  - pymdownx.arithmatex:\\n      generic: true\\n  - def_list\\n  - pymdownx.tasklist:\\n      custom_checkbox: true\\n      clickable_checkbox: false\\n\\n\\nplugins:\\n  - search\\n  - tags\\n  - git-revision-date-localized:\\n      enable_creation_date: true\\n      type: datetime\\n      enabled: true\\n      enable_creation_date: true\\n      fallback_to_build_date: true\\n      locale: en\\n\\n\\nextra:\\n  tags:\\n    Homepage: homepage\\n    Index: index\\n    Overview: overview\\n    Test: test\\n    Infra: infra\\n    Documentation: doc\\n    Legal: legal\\n    Usu\u00e1rio: user\\n    API: API\\n    Browser: browser\\n\\n  status:\\n    new: Recently Added!\\n\\n\\ncopyright: Only God knows\\n\\n\\n'\n</code></pre>"},{"location":"mosheh/constants.py/#file_markdown","title":"<code>FILE_MARKDOWN</code>","text":"<p>Type: <code>Final[str]</code></p> <p>Value: <code>'# File:</code><code>\\n\\nRole: {role}\\n\\nPath:</code><code>\\n\\n{filedoc}\\n\\n---\\n\\n## Imports\\n\\n{imports}\\n\\n---\\n\\n## Consts\\n\\n{constants}\\n\\n---\\n\\n## Classes\\n\\n{classes}\\n\\n---\\n\\n## Functions\\n\\n{functions}\\n\\n---\\n\\n## Assertions\\n\\n{assertions}\\n'</code></p> SNIPPET Python<pre><code>FILE_MARKDOWN: Final[str] = '# File: `{filename}`\\n\\nRole: {role}\\n\\nPath: `{filepath}`\\n\\n{filedoc}\\n\\n---\\n\\n## Imports\\n\\n{imports}\\n\\n---\\n\\n## Consts\\n\\n{constants}\\n\\n---\\n\\n## Classes\\n\\n{classes}\\n\\n---\\n\\n## Functions\\n\\n{functions}\\n\\n---\\n\\n## Assertions\\n\\n{assertions}\\n'\n</code></pre>"},{"location":"mosheh/constants.py/#import_md_struct","title":"<code>IMPORT_MD_STRUCT</code>","text":"<p>Type: <code>Final[str]</code></p> <p>Value: <code>'###</code>#!py import {name}<code>\\n\\nPath:</code>#!py {_path}<code>\\n\\nCategory: {category}\\n\\n??? example \"SNIPPET\"\\n\\n    ```py\\n{code}\\n    ```\\n\\n'</code></p> SNIPPET Python<pre><code>IMPORT_MD_STRUCT: Final[str] = '### `#!py import {name}`\\n\\nPath: `#!py {_path}`\\n\\nCategory: {category}\\n\\n??? example \"SNIPPET\"\\n\\n    ```py\\n{code}\\n    ```\\n\\n'\n</code></pre>"},{"location":"mosheh/constants.py/#assign_md_struct","title":"<code>ASSIGN_MD_STRUCT</code>","text":"<p>Type: <code>Final[str]</code></p> <p>Value: <code>'###</code>#!py {token}<code>\\n\\nType:</code>#!py {_type}<code>\\n\\nValue:</code>#!py {value}<code>\\n\\n??? example \"SNIPPET\"\\n\\n    ```py\\n{code}\\n    ```\\n\\n'</code></p> SNIPPET Python<pre><code>ASSIGN_MD_STRUCT: Final[str] = '### `#!py {token}`\\n\\nType: `#!py {_type}`\\n\\nValue: `#!py {value}`\\n\\n??? example \"SNIPPET\"\\n\\n    ```py\\n{code}\\n    ```\\n\\n'\n</code></pre>"},{"location":"mosheh/constants.py/#class_def_md_struct","title":"<code>CLASS_DEF_MD_STRUCT</code>","text":"<p>Type: <code>Final[str]</code></p> <p>Value: <code>'###</code>#!py class {name}<code>\\n\\nParents:</code><code>\\n\\nDecorators:</code>#!py {decorators}<code>\\n\\nKwargs:</code>#!py {kwargs}<code>\\n\\n{docstring}\\n\\n??? example \"SNIPPET\"\\n\\n    ```py\\n{code}\\n    ```\\n\\n'</code></p> SNIPPET Python<pre><code>CLASS_DEF_MD_STRUCT: Final[str] = '### `#!py class {name}`\\n\\nParents: `{inherit}`\\n\\nDecorators: `#!py {decorators}`\\n\\nKwargs: `#!py {kwargs}`\\n\\n{docstring}\\n\\n??? example \"SNIPPET\"\\n\\n    ```py\\n{code}\\n    ```\\n\\n'\n</code></pre>"},{"location":"mosheh/constants.py/#function_def_md_struct","title":"<code>FUNCTION_DEF_MD_STRUCT</code>","text":"<p>Type: <code>Final[str]</code></p> <p>Value: <code>'###</code>#!py def {name}<code>\\n\\nType:</code>#!py {category}<code>\\n\\nReturn Type:</code>#!py {rtype}<code>\\n\\nDecorators:</code>#!py {decorators}<code>\\n\\nArgs:</code>#!py {args}<code>\\n\\nKwargs:</code>#!py {kwargs}<code>\\n\\n{docstring}\\n\\n??? example \"SNIPPET\"\\n\\n    ```py\\n{code}\\n    ```\\n\\n'</code></p> SNIPPET Python<pre><code>FUNCTION_DEF_MD_STRUCT: Final[str] = '### `#!py def {name}`\\n\\nType: `#!py {category}`\\n\\nReturn Type: `#!py {rtype}`\\n\\nDecorators: `#!py {decorators}`\\n\\nArgs: `#!py {args}`\\n\\nKwargs: `#!py {kwargs}`\\n\\n{docstring}\\n\\n??? example \"SNIPPET\"\\n\\n    ```py\\n{code}\\n    ```\\n\\n'\n</code></pre>"},{"location":"mosheh/constants.py/#assert_md_struct","title":"<code>ASSERT_MD_STRUCT</code>","text":"<p>Type: <code>Final[str]</code></p> <p>Value: <code>'###</code>#!py assert {test}<code>\\n\\nMessage:</code>#!py {msg}<code>\\n\\n??? example \"SNIPPET\"\\n\\n    ```py\\n{code}\\n    ```\\n\\n'</code></p> SNIPPET Python<pre><code>ASSERT_MD_STRUCT: Final[str] = '### `#!py assert {test}`\\n\\nMessage: `#!py {msg}`\\n\\n??? example \"SNIPPET\"\\n\\n    ```py\\n{code}\\n    ```\\n\\n'\n</code></pre>"},{"location":"mosheh/constants.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"mosheh/constants.py/#functions","title":"Functions","text":"<p>NO FUNCTION DEFINED HERE</p>"},{"location":"mosheh/constants.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"mosheh/custom_types.py/","title":"File: <code>custom_types.py</code>","text":"<p>Role: Python Source Code</p> <p>Path: <code>mosheh</code></p> <p>For every type hint and notation that goes beyond the traditional, there is a custom type here created.</p> <p>The idea of this types is to keep everything logical and short, with proper types and in-code description. This is a way to turn Python into a \"typed\" lang, kinda.</p> <p>The <code>Statement</code>, <code>ImportType</code>, <code>FunctionType</code> and <code>FileRole</code> classes are enums with a really useful function: to standardize the possible types of their own types (for example, a function strictly assumes only 4 different types, and exactly one of them).</p> <p>The other ones are <code>typing.TypeAlias</code>, simpler but also fuctional.</p>"},{"location":"mosheh/custom_types.py/#imports","title":"Imports","text":""},{"location":"mosheh/custom_types.py/#import-enum","title":"<code>import Enum</code>","text":"<p>Path: <code>enum</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from enum import Enum\n</code></pre>"},{"location":"mosheh/custom_types.py/#import-auto","title":"<code>import auto</code>","text":"<p>Path: <code>enum</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from enum import auto\n</code></pre>"},{"location":"mosheh/custom_types.py/#import-typealias","title":"<code>import TypeAlias</code>","text":"<p>Path: <code>typing</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from typing import TypeAlias\n</code></pre>"},{"location":"mosheh/custom_types.py/#consts","title":"Consts","text":"<p>NO CONSTANT DEFINED HERE</p>"},{"location":"mosheh/custom_types.py/#classes","title":"Classes","text":""},{"location":"mosheh/custom_types.py/#class-statement","title":"<code>class Statement</code>","text":"<p>Parents: <code>Enum</code></p> <p>Decorators: <code>None</code></p> <p>Kwargs: <code>None</code></p> <p>Enum-like class to enumerate in-code the dealed statements.</p> SNIPPET Python<pre><code>class Statement(Enum):\n    \"\"\"Enum-like class to enumerate in-code the dealed statements.\"\"\"\n    Import = auto()\n    ImportFrom = auto()\n    Assign = auto()\n    AnnAssign = auto()\n    ClassDef = auto()\n    FunctionDef = auto()\n    AsyncFunctionDef = auto()\n    Assert = auto()\n</code></pre>"},{"location":"mosheh/custom_types.py/#class-importtype","title":"<code>class ImportType</code>","text":"<p>Parents: <code>Enum</code></p> <p>Decorators: <code>None</code></p> <p>Kwargs: <code>None</code></p> <p>Enum-like class to enumerate in-code the import types.</p> SNIPPET Python<pre><code>class ImportType(Enum):\n    \"\"\"Enum-like class to enumerate in-code the import types.\"\"\"\n    Native = 'Native'\n    TrdParty = '3rd Party'\n    Local = 'Local'\n</code></pre>"},{"location":"mosheh/custom_types.py/#class-functiontype","title":"<code>class FunctionType</code>","text":"<p>Parents: <code>Enum</code></p> <p>Decorators: <code>None</code></p> <p>Kwargs: <code>None</code></p> <p>Enum-like class to enumerate in-code the function types.</p> SNIPPET Python<pre><code>class FunctionType(Enum):\n    \"\"\"Enum-like class to enumerate in-code the function types.\"\"\"\n    Function = 'Function'\n    Method = 'Method'\n    Generator = 'Generator'\n    Coroutine = 'Coroutine'\n</code></pre>"},{"location":"mosheh/custom_types.py/#class-filerole","title":"<code>class FileRole</code>","text":"<p>Parents: <code>Enum</code></p> <p>Decorators: <code>None</code></p> <p>Kwargs: <code>None</code></p> <p>Enum-like class to enumerate in-code the files investigated.</p> SNIPPET Python<pre><code>class FileRole(Enum):\n    \"\"\"Enum-like class to enumerate in-code the files investigated.\"\"\"\n    PythonSourceCode = 'Python Source Code'\n</code></pre>"},{"location":"mosheh/custom_types.py/#functions","title":"Functions","text":"<p>NO FUNCTION DEFINED HERE</p>"},{"location":"mosheh/custom_types.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"mosheh/doc.py/","title":"File: <code>doc.py</code>","text":"<p>Role: Python Source Code</p> <p>Path: <code>mosheh</code></p> <p>Used to create the output documentation, this file deals with the codebase generated <code>custom_types.CodebaseDict</code> and creates <code>.md</code> files based on its collected information.</p> <p>The only public/exposed function here is <code>generate_doc</code>, which takes care of all of the private functions.</p> <p>There is a function for each step and statement type: <code>ast.Import</code>, <code>ast.ImportFrom</code>, <code>ast.Assign</code>, <code>ast.AnnAssign</code>, <code>ast.ClassDef</code>, <code>ast.FunctionDef</code>, <code>ast.AsyncFunctionDef</code> and <code>ast.Assert</code>, plus utility stuff like processing files.</p>"},{"location":"mosheh/doc.py/#imports","title":"Imports","text":""},{"location":"mosheh/doc.py/#import-subprocess","title":"<code>import subprocess</code>","text":"<p>Path: <code>None</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>import subprocess\n</code></pre>"},{"location":"mosheh/doc.py/#import-logger","title":"<code>import Logger</code>","text":"<p>Path: <code>logging</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from logging import Logger\n</code></pre>"},{"location":"mosheh/doc.py/#import-getlogger","title":"<code>import getLogger</code>","text":"<p>Path: <code>logging</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from logging import getLogger\n</code></pre>"},{"location":"mosheh/doc.py/#import-makedirs","title":"<code>import makedirs</code>","text":"<p>Path: <code>os</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from os import makedirs\n</code></pre>"},{"location":"mosheh/doc.py/#import-path","title":"<code>import path</code>","text":"<p>Path: <code>os</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from os import path\n</code></pre>"},{"location":"mosheh/doc.py/#import-copy2","title":"<code>import copy2</code>","text":"<p>Path: <code>shutil</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from shutil import copy2\n</code></pre>"},{"location":"mosheh/doc.py/#import-cast","title":"<code>import cast</code>","text":"<p>Path: <code>typing</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from typing import cast\n</code></pre>"},{"location":"mosheh/doc.py/#import-assert_md_struct","title":"<code>import ASSERT_MD_STRUCT</code>","text":"<p>Path: <code>constants</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from constants import ASSERT_MD_STRUCT\n</code></pre>"},{"location":"mosheh/doc.py/#import-assign_md_struct","title":"<code>import ASSIGN_MD_STRUCT</code>","text":"<p>Path: <code>constants</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from constants import ASSIGN_MD_STRUCT\n</code></pre>"},{"location":"mosheh/doc.py/#import-class_def_md_struct","title":"<code>import CLASS_DEF_MD_STRUCT</code>","text":"<p>Path: <code>constants</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from constants import CLASS_DEF_MD_STRUCT\n</code></pre>"},{"location":"mosheh/doc.py/#import-default_mkdocs_yml","title":"<code>import DEFAULT_MKDOCS_YML</code>","text":"<p>Path: <code>constants</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from constants import DEFAULT_MKDOCS_YML\n</code></pre>"},{"location":"mosheh/doc.py/#import-file_markdown","title":"<code>import FILE_MARKDOWN</code>","text":"<p>Path: <code>constants</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from constants import FILE_MARKDOWN\n</code></pre>"},{"location":"mosheh/doc.py/#import-function_def_md_struct","title":"<code>import FUNCTION_DEF_MD_STRUCT</code>","text":"<p>Path: <code>constants</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from constants import FUNCTION_DEF_MD_STRUCT\n</code></pre>"},{"location":"mosheh/doc.py/#import-import_md_struct","title":"<code>import IMPORT_MD_STRUCT</code>","text":"<p>Path: <code>constants</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from constants import IMPORT_MD_STRUCT\n</code></pre>"},{"location":"mosheh/doc.py/#import-codebasedict","title":"<code>import CodebaseDict</code>","text":"<p>Path: <code>custom_types</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from custom_types import CodebaseDict\n</code></pre>"},{"location":"mosheh/doc.py/#import-filerole","title":"<code>import FileRole</code>","text":"<p>Path: <code>custom_types</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from custom_types import FileRole\n</code></pre>"},{"location":"mosheh/doc.py/#import-functiontype","title":"<code>import FunctionType</code>","text":"<p>Path: <code>custom_types</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from custom_types import FunctionType\n</code></pre>"},{"location":"mosheh/doc.py/#import-importtype","title":"<code>import ImportType</code>","text":"<p>Path: <code>custom_types</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from custom_types import ImportType\n</code></pre>"},{"location":"mosheh/doc.py/#import-standardreturn","title":"<code>import StandardReturn</code>","text":"<p>Path: <code>custom_types</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from custom_types import StandardReturn\n</code></pre>"},{"location":"mosheh/doc.py/#import-statement","title":"<code>import Statement</code>","text":"<p>Path: <code>custom_types</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from custom_types import Statement\n</code></pre>"},{"location":"mosheh/doc.py/#import-indent_code","title":"<code>import indent_code</code>","text":"<p>Path: <code>utils</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from utils import indent_code\n</code></pre>"},{"location":"mosheh/doc.py/#consts","title":"Consts","text":""},{"location":"mosheh/doc.py/#nav_dirs","title":"<code>NAV_DIRS</code>","text":"<p>Type: <code>list[str]</code></p> <p>Value: <code>[]</code></p> SNIPPET Python<pre><code>NAV_DIRS: list[str] = []\n</code></pre>"},{"location":"mosheh/doc.py/#nav_md","title":"<code>NAV_MD</code>","text":"<p>Type: <code>list[str]</code></p> <p>Value: <code>['nav:\\n  - Homepage: index.md\\n']</code></p> SNIPPET Python<pre><code>NAV_MD: list[str] = ['nav:\\n  - Homepage: index.md\\n']\n</code></pre>"},{"location":"mosheh/doc.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"mosheh/doc.py/#functions","title":"Functions","text":""},{"location":"mosheh/doc.py/#def-generate_doc","title":"<code>def generate_doc</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>None</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>None</code></p> <p>Kwargs: <code>codebase: CodebaseDict, root: str, output: str, proj_name: str, logo_path: str | None, readme_path: str | None, edit_uri: str = 'blob/main/documentation/docs', repo_name: str = 'GitHub', repo_url: str = 'https://github.com'</code></p> <p>Generates a documentation structure for a Python codebase using MkDocs.</p> <p>This function creates a new MkDocs project at the specified output path, writes a configuration file, and processes the provided codebase to generate documentation.</p> <p>Key concepts:</p> <ul> <li>Kwargs: By starting args with \"*\", this function only accepts key-word arguments.</li> <li>MkDocs: A static site generator that's geared towards project documentation.</li> <li>Codebase Processing: The function relies on <code>process_codebase</code> to handle the   codebase structure and populate the documentation content based on Python files   and their stmts.</li> <li>Configuration: Builds a <code>mkdocs.yml</code> configuration file with project details,   including repository information and editing URI.</li> <li>Homepage: If <code>readme_path</code> is provided, so the <code>index.md</code> file provided by MkDocs   is overwriten by the <code>README.md</code> found at provided <code>readme_path</code> file.</li> </ul> <p>:param codebase: Dict containing nodes representing <code>.py</code> files and their stmts.</p> <p>:type codebase: CodebaseDict</p> <p>:param root: Root dir, where the analysis starts.</p> <p>:type root: str</p> <p>:param output: Path for documentation output, where to be created.</p> <p>:type output: str</p> <p>:param proj_name: The name of the project, for generating MkDocs configuration.</p> <p>:type proj_name: str</p> <p>:param logo_path: Path for doc/project logo, same Material MkDocs's formats.</p> <p>:type logo_path: str | None</p> <p>:param readme_path: The path of the <code>README.md</code> file, to be used as homepage.</p> <p>:type readme_path: str | None</p> <p>:param edit_uri: URI to view raw or edit blob file, default is <code>'blob/main/documentation/docs'</code>.</p> <p>:type edit_uri: str</p> <p>:param repo_name: Name of the code repository to be mapped, default is <code>'GitHub'</code>.</p> <p>:type repo_name: str</p> <p>:param repo_url: The URL of the repository, used for linking in the documentation.</p> <p>:type repo_url: str</p> <p>:return: Nothing, just generates documentation files in the specified output path.</p> <p>:rtype: None</p> SNIPPET Python<pre><code>def generate_doc(*, codebase: CodebaseDict, root: str, output: str, proj_name: str, logo_path: str | None, readme_path: str | None, edit_uri: str='blob/main/documentation/docs', repo_name: str='GitHub', repo_url: str='https://github.com') -&gt; None:\n    \"\"\"\n    Generates a documentation structure for a Python codebase using MkDocs.\n\n    This function creates a new MkDocs project at the specified output path, writes a\n    configuration file, and processes the provided codebase to generate documentation.\n\n    Key concepts:\n    - Kwargs: By starting args with \"*\", this function only accepts key-word arguments.\n    - MkDocs: A static site generator that's geared towards project documentation.\n    - Codebase Processing: The function relies on `process_codebase` to handle the\n      codebase structure and populate the documentation content based on Python files\n      and their stmts.\n    - Configuration: Builds a `mkdocs.yml` configuration file with project details,\n      including repository information and editing URI.\n    - Homepage: If `readme_path` is provided, so the `index.md` file provided by MkDocs\n      is overwriten by the `README.md` found at provided `readme_path` file.\n\n    :param codebase: Dict containing nodes representing `.py` files and their stmts.\n    :type codebase: CodebaseDict\n    :param root: Root dir, where the analysis starts.\n    :type root: str\n    :param output: Path for documentation output, where to be created.\n    :type output: str\n    :param proj_name: The name of the project, for generating MkDocs configuration.\n    :type proj_name: str\n    :param logo_path: Path for doc/project logo, same Material MkDocs's formats.\n    :type logo_path: str | None\n    :param readme_path: The path of the `README.md` file, to be used as homepage.\n    :type readme_path: str | None\n    :param edit_uri: URI to view raw or edit blob file, default is\n                        `'blob/main/documentation/docs'`.\n    :type edit_uri: str\n    :param repo_name: Name of the code repository to be mapped, default is `'GitHub'`.\n    :type repo_name: str\n    :param repo_url: The URL of the repository, used for linking in the documentation.\n    :type repo_url: str\n    :return: Nothing, just generates documentation files in the specified output path.\n    :rtype: None\n    \"\"\"\n    output_path: str = path.abspath(output)\n    mkdocs_yml: str = path.join(output_path, 'mkdocs.yml')\n    try:\n        logger.debug('Running MkDocs')\n        result = subprocess.run(['mkdocs', 'new', output_path], check=True, capture_output=True, text=True)\n        logger.debug(result.stdout)\n        logger.info('MkDocs created')\n    except subprocess.CalledProcessError as e:\n        logger.critical(f'Error: {e.stderr}')\n        raise e\n    logger.info('Creating default mkdocs.yml')\n    with open(mkdocs_yml, 'w', encoding='utf-8') as f:\n        f.write(_default_doc_config(proj_name=proj_name, output=output, logo_path=logo_path, edit_uri=edit_uri, repo_name=repo_name, repo_url=repo_url))\n    logger.info('Processing codebase')\n    _process_codebase(codebase, root, output)\n    with open(mkdocs_yml, 'a', encoding='utf-8') as f:\n        f.writelines(NAV_MD)\n        logger.debug('Nav added to mkdocs.yml')\n    if readme_path is not None:\n        homepage: str = path.join(output_path, 'docs', 'index.md')\n        with open(readme_path, encoding='utf-8') as f:\n            logger.debug(f'{readme_path} read')\n            content: list[str] = f.readlines()\n        with open(homepage, 'w', encoding='utf-8') as f:\n            logger.debug(f'{homepage} written')\n            f.writelines(content)\n        logger.info('README.md copied to documentation')\n</code></pre>"},{"location":"mosheh/doc.py/#def-_default_doc_config","title":"<code>def _default_doc_config</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>str</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>None</code></p> <p>Kwargs: <code>proj_name: str, output: str, logo_path: str | None, edit_uri: str = 'blob/main/documentation/docs', repo_name: str = 'GitHub', repo_url: str = 'https://github.com/'</code></p> <p>Generates the default configuration for an MkDocs documentation project.</p> <p>This function creates an <code>mkdocs.yml</code> configuration file with project details, repository information, and an optional logo. If a logo is provided, it is copied to the documentation's image directory.</p> <p>Key features:</p> <ul> <li>Supports setting project and repository information.</li> <li>Handles optional logos and ensures they are placed in the correct directory.</li> <li>Returns a formatted YAML configuration as a string.</li> </ul> <p>:param proj_name: The name of the project, for generating MkDocs configuration.</p> <p>:type proj_name: str</p> <p>:param output: Path for documentation output, where to be created.</p> <p>:type output: str</p> <p>:param logo_path: Path for doc/project logo, same Material MkDocs's formats.</p> <p>:type logo_path: str</p> <p>:param edit_uri: URI to view raw or edit blob file, default is <code>'blob/main/documentation/docs'</code>.</p> <p>:type edit_uri: str</p> <p>:param repo_name: Name of the code repository to be mapped, default is <code>'GitHub'</code>.</p> <p>:type repo_name: str</p> <p>:param repo_url: The URL of the repository, used for linking in the documentation.</p> <p>:type repo_url: str</p> <p>:return: Formatted MkDocs YAML configuration.</p> <p>:rtype: str</p> SNIPPET Python<pre><code>def _default_doc_config(*, proj_name: str, output: str, logo_path: str | None, edit_uri: str='blob/main/documentation/docs', repo_name: str='GitHub', repo_url: str='https://github.com/') -&gt; str:\n    \"\"\"\n    Generates the default configuration for an MkDocs documentation project.\n\n    This function creates an `mkdocs.yml` configuration file with project details,\n    repository information, and an optional logo. If a logo is provided, it is copied\n    to the documentation's image directory.\n\n    Key features:\n    - Supports setting project and repository information.\n    - Handles optional logos and ensures they are placed in the correct directory.\n    - Returns a formatted YAML configuration as a string.\n\n    :param proj_name: The name of the project, for generating MkDocs configuration.\n    :type proj_name: str\n    :param output: Path for documentation output, where to be created.\n    :type output: str\n    :param logo_path: Path for doc/project logo, same Material MkDocs's formats.\n    :type logo_path: str\n    :param edit_uri: URI to view raw or edit blob file, default is\n                        `'blob/main/documentation/docs'`.\n    :type edit_uri: str\n    :param repo_name: Name of the code repository to be mapped, default is `'GitHub'`.\n    :type repo_name: str\n    :param repo_url: The URL of the repository, used for linking in the documentation.\n    :type repo_url: str\n    :return: Formatted MkDocs YAML configuration.\n    :rtype: str\n    \"\"\"\n    if logo_path is not None:\n        ext: str = path.splitext(logo_path)[-1]\n        logo_file_path: str = path.join(output, 'docs', 'img')\n        file_name: str = path.join(logo_file_path, f'logo{ext}')\n        logger.debug('Logo path handling done')\n        if not path.exists(logo_file_path):\n            makedirs(logo_file_path)\n            logger.debug(f'{logo_file_path} logo file path created')\n        copy2(logo_path, file_name)\n        logger.info(f'{logo_path} copied to {file_name}')\n        logo_path = file_name.removeprefix(path.join(output, 'docs', ''))\n    else:\n        logo_path = 'https://squidfunk.github.io/mkdocs-material/assets/favicon.png'\n    return DEFAULT_MKDOCS_YML.format(proj_name=proj_name, edit_uri=edit_uri, repo_name=repo_name, repo_url=repo_url, logo_path=logo_path)\n</code></pre>"},{"location":"mosheh/doc.py/#def-_codebase_to_markdown","title":"<code>def _codebase_to_markdown</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>str</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>filedata: list[StandardReturn], basedir: str</code></p> <p>Kwargs: <code>None</code></p> <p>Converts a file's processed data into a structured Markdown representation.</p> <p>This function processes a list of stmts extracted from a Python file and generates a Markdown-formatted string. It categorizes stmts into imports, constants, classes, functions, and assertions, ensuring that each type is documented appropriately. If a category has no stmts, a default informational message is added.</p> <p>Key concepts:</p> <ul> <li>Statement Handling: The function processes different types of stmts   (imports, assignments, class and function definitions, etc.) and organizes   them into corresponding sections.</li> <li>Markdown Generation: The output is formatted using a predefined Markdown   template (<code>FILE_MARKDOWN</code>) that structures the documentation by category.</li> <li>Category Defaults: If no stmts exist for a particular category, an   informational block is added to indicate its absence.</li> </ul> <p>Example:</p> Python<pre><code>filedata: list[StandardReturn] = [\n    {'statement': Statement.Import, 'name': 'os', ...},\n    {'statement': Statement.ClassDef, 'name': 'MyClass', ...},\n]\n_codebase_to_markdown(filedata, '/path/to/module/file.py')\n# Outputs a Markdown string with sections for imports and classes\n</code></pre> <p>:param filedata: A list of statement dict for the parsed contents of a Python file.</p> <p>:type filedata: list[StandardReturn]</p> <p>:param basedir: The file in-process' base dir, used to generate the module path.</p> <p>:type basedir: str</p> <p>:return: A Markdown-formatted string documenting the contents of the file.</p> <p>:rtype: str</p> SNIPPET Python<pre><code>def _codebase_to_markdown(filedata: list[StandardReturn], basedir: str) -&gt; str:\n    \"\"\"\n    Converts a file's processed data into a structured Markdown representation.\n\n    This function processes a list of stmts extracted from a Python file and\n    generates a Markdown-formatted string. It categorizes stmts into imports,\n    constants, classes, functions, and assertions, ensuring that each type is\n    documented appropriately. If a category has no stmts, a default informational\n    message is added.\n\n    Key concepts:\n    - Statement Handling: The function processes different types of stmts\n      (imports, assignments, class and function definitions, etc.) and organizes\n      them into corresponding sections.\n    - Markdown Generation: The output is formatted using a predefined Markdown\n      template (`FILE_MARKDOWN`) that structures the documentation by category.\n    - Category Defaults: If no stmts exist for a particular category, an\n      informational block is added to indicate its absence.\n\n    Example:\n    ```python\n    filedata: list[StandardReturn] = [\n        {'statement': Statement.Import, 'name': 'os', ...},\n        {'statement': Statement.ClassDef, 'name': 'MyClass', ...},\n    ]\n    _codebase_to_markdown(filedata, '/path/to/module/file.py')\n    # Outputs a Markdown string with sections for imports and classes\n    ```\n\n    :param filedata: A list of statement dict for the parsed contents of a Python file.\n    :type filedata: list[StandardReturn]\n    :param basedir: The file in-process' base dir, used to generate the module path.\n    :type basedir: str\n    :return: A Markdown-formatted string documenting the contents of the file.\n    :rtype: str\n    \"\"\"\n    __meta__: StandardReturn = filedata.pop(0)\n    filename: str = basedir.split(path.sep)[-1]\n    role: str = cast(FileRole, __meta__.get('__role__')).value\n    filepath: str = basedir.removesuffix(filename).replace(path.sep, '.').removesuffix('.')\n    filedoc: str = cast(str, __meta__.get('__docstring__'))\n    imports: str = ''\n    constants: str = ''\n    classes: str = ''\n    functions: str = ''\n    assertions: str = ''\n    logger.debug(f'File: {basedir}')\n    for stmt in filedata:\n        match stmt['statement']:\n            case Statement.Import:\n                imports += _handle_import(stmt)\n                logger.debug(f'\\tStatement: {stmt}')\n            case Statement.ImportFrom:\n                imports += _handle_import_from(stmt)\n                logger.debug(f'\\tStatement: {stmt}')\n            case Statement.Assign:\n                constants += _handle_assign(stmt)\n                logger.debug(f'\\tStatement: {stmt}')\n            case Statement.AnnAssign:\n                constants += _handle_annassign(stmt)\n                logger.debug(f'\\tStatement: {stmt}')\n            case Statement.ClassDef:\n                classes += _handle_class_def(stmt)\n                logger.debug(f'\\tStatement: {stmt}')\n            case Statement.FunctionDef | Statement.AsyncFunctionDef:\n                functions += _handle_function_def(stmt)\n                logger.debug(f'\\tStatement: {stmt}')\n            case Statement.Assert:\n                assertions += _handle_assert(stmt)\n                logger.debug(f'\\tStatement: {stmt}')\n            case _:\n                logger.error('Statement shoud not be processed here:')\n                logger.error(stmt['statement'])\n    if not len(imports):\n        logger.debug('No imports defined here')\n        imports = '!!! info \"NO IMPORT DEFINED HERE\"'\n    if not len(constants):\n        logger.debug('No constants defined here')\n        constants = '!!! info \"NO CONSTANT DEFINED HERE\"'\n    if not len(classes):\n        logger.debug('No classes defined here')\n        classes = '!!! info \"NO CLASS DEFINED HERE\"'\n    if not len(functions):\n        logger.debug('No functions defined here')\n        functions = '!!! info \"NO FUNCTION DEFINED HERE\"'\n    if not len(assertions):\n        logger.debug('No assertions defined here')\n        assertions = '!!! info \"NO ASSERT DEFINED HERE\"'\n    return FILE_MARKDOWN.format(filename=filename, role=role, filepath=filepath, filedoc=filedoc, imports=imports, constants=constants, classes=classes, functions=functions, assertions=assertions)\n</code></pre>"},{"location":"mosheh/doc.py/#def-_handle_import","title":"<code>def _handle_import</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>str</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>stmt: StandardReturn</code></p> <p>Kwargs: <code>None</code></p> <p>Generates a Markdown representation for an import statement.</p> <p>This function processes an <code>import</code> statement from a parsed Python file, formatting it into a structured Markdown block. The output includes the import name, category, and the indented code snippet.</p> <p>Key concepts:</p> <ul> <li>Import Handling: Extracts the import statement's details (name, category, code)   and formats them for documentation.</li> <li>Indentation: The <code>indent_code</code> function is used to apply consistent indentation   to the statement code before including it in the Markdown output.</li> <li>MD Struct: The output Markdown uses a predefined template - <code>IMPORT_MD_STRUCT</code>.</li> </ul> <p>Example:</p> Python<pre><code>stmt: StandardReturn = {\n    'statement': Statement.Import,\n    'name': 'os',\n    'category': ImportType.Native,\n    'code': 'import os',\n}\nhandle_import(stmt)\n# Outputs a formatted Markdown string representing the import\n</code></pre> <p>:param stmt: A dict containing the details of the import statement.</p> <p>:type stmt: StandardReturn</p> <p>:return: A formatted Markdown string documenting the import statement.</p> <p>:rtype: str</p> SNIPPET Python<pre><code>def _handle_import(stmt: StandardReturn) -&gt; str:\n    \"\"\"\n    Generates a Markdown representation for an import statement.\n\n    This function processes an `import` statement from a parsed Python file, formatting\n    it into a structured Markdown block. The output includes the import name, category,\n    and the indented code snippet.\n\n    Key concepts:\n    - Import Handling: Extracts the import statement's details (name, category, code)\n      and formats them for documentation.\n    - Indentation: The `indent_code` function is used to apply consistent indentation\n      to the statement code before including it in the Markdown output.\n    - MD Struct: The output Markdown uses a predefined template - `IMPORT_MD_STRUCT`.\n\n    Example:\n    ```python\n    stmt: StandardReturn = {\n        'statement': Statement.Import,\n        'name': 'os',\n        'category': ImportType.Native,\n        'code': 'import os',\n    }\n    handle_import(stmt)\n    # Outputs a formatted Markdown string representing the import\n    ```\n\n    :param stmt: A dict containing the details of the import statement.\n    :type stmt: StandardReturn\n    :return: A formatted Markdown string documenting the import statement.\n    :rtype: str\n    \"\"\"\n    name: str = cast(str, stmt['name'])\n    _path: None = None\n    category: str = cast(ImportType, stmt['category']).value\n    _code: str = cast(str, stmt['code'])\n    code: str = indent_code(_code)\n    return IMPORT_MD_STRUCT.format(name=name, _path=_path, category=category, code=code)\n</code></pre>"},{"location":"mosheh/doc.py/#def-_handle_import_from","title":"<code>def _handle_import_from</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>str</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>stmt: StandardReturn</code></p> <p>Kwargs: <code>None</code></p> <p>Generates a Markdown representation for an import statement.</p> <p>This function processes a <code>from ... import ...</code> statement from a parsed Python file, formatting it into a structured Markdown block. The output includes the import name, category, and the indented code snippet.</p> <p>Key concepts:</p> <ul> <li>Import Handling: Extracts the import statement's details (name, category, code)   and formats them for documentation.</li> <li>Indentation: The <code>indent_code</code> function is used to apply consistent indentation   to the statement code before including it in the Markdown output.</li> <li>MD Struct: The output Markdown uses a predefined template - <code>IMPORT_MD_STRUCT</code>.</li> </ul> <p>Example:</p> Python<pre><code>stmt: StandardReturn = {\n    'statement': Statement.ImportFrom,\n    'name': 'environ',\n    'category': ImportType.Native,\n    'code': 'from os import environ',\n}\nhandle_import(stmt)\n# Outputs a formatted Markdown string representing the import\n</code></pre> <p>:param stmt: A dict containing the details of the import statement.</p> <p>:type stmt: StandardReturn</p> <p>:return: A formatted Markdown string documenting the import statement.</p> <p>:rtype: str</p> SNIPPET Python<pre><code>def _handle_import_from(stmt: StandardReturn) -&gt; str:\n    \"\"\"\n    Generates a Markdown representation for an import statement.\n\n    This function processes a `from ... import ...` statement from a parsed Python\n    file, formatting it into a structured Markdown block. The output includes the\n    import name, category, and the indented code snippet.\n\n    Key concepts:\n    - Import Handling: Extracts the import statement's details (name, category, code)\n      and formats them for documentation.\n    - Indentation: The `indent_code` function is used to apply consistent indentation\n      to the statement code before including it in the Markdown output.\n    - MD Struct: The output Markdown uses a predefined template - `IMPORT_MD_STRUCT`.\n\n    Example:\n    ```python\n    stmt: StandardReturn = {\n        'statement': Statement.ImportFrom,\n        'name': 'environ',\n        'category': ImportType.Native,\n        'code': 'from os import environ',\n    }\n    handle_import(stmt)\n    # Outputs a formatted Markdown string representing the import\n    ```\n\n    :param stmt: A dict containing the details of the import statement.\n    :type stmt: StandardReturn\n    :return: A formatted Markdown string documenting the import statement.\n    :rtype: str\n    \"\"\"\n    name: str = cast(str, stmt['name'])\n    _path: str = cast(str, stmt['path'])\n    category: str = cast(ImportType, stmt['category']).value\n    code: str = indent_code(f'from {_path} import {name}')\n    return IMPORT_MD_STRUCT.format(name=name, _path=_path, category=category, code=code)\n</code></pre>"},{"location":"mosheh/doc.py/#def-_handle_assign","title":"<code>def _handle_assign</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>str</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>stmt: StandardReturn</code></p> <p>Kwargs: <code>None</code></p> <p>Generates a Markdown representation for an <code>assign</code> statement.</p> <p>This function processes an assign statement from a parsed Python file, formatting it into a structured Markdown block. The output includes the assign name, category, and the indented code snippet.</p> <p>Key concepts:</p> <ul> <li>Import Handling: Extracts the assign statement's details (tokens, value, code)   and formats them for documentation.</li> <li>Indentation: The <code>indent_code</code> function is used to apply consistent indentation   to the statement code before including it in the Markdown output.</li> <li>MD Struct: The output Markdown uses a predefined template - <code>ASSIGN_MD_STRUCT</code>.</li> </ul> <p>Example:</p> Python<pre><code>stmt: StandardReturn = {\n    'statement': Statement.Assign,\n    'tokens': ['foo', 'bar'],\n    'value': '(True, False)',\n    'code': 'foo, bar = True, False',\n}\nhandle_assign(stmt)\n# Outputs a formatted Markdown string representing the assign\n</code></pre> <p>:param stmt: A dict containing the details of the assign statement.</p> <p>:type stmt: StandardReturn</p> <p>:return: A formatted Markdown string documenting the assign statement.</p> <p>:rtype: str</p> SNIPPET Python<pre><code>def _handle_assign(stmt: StandardReturn) -&gt; str:\n    \"\"\"\n    Generates a Markdown representation for an `assign` statement.\n\n    This function processes an assign statement from a parsed Python file, formatting\n    it into a structured Markdown block. The output includes the assign name, category,\n    and the indented code snippet.\n\n    Key concepts:\n    - Import Handling: Extracts the assign statement's details (tokens, value, code)\n      and formats them for documentation.\n    - Indentation: The `indent_code` function is used to apply consistent indentation\n      to the statement code before including it in the Markdown output.\n    - MD Struct: The output Markdown uses a predefined template - `ASSIGN_MD_STRUCT`.\n\n    Example:\n    ```python\n    stmt: StandardReturn = {\n        'statement': Statement.Assign,\n        'tokens': ['foo', 'bar'],\n        'value': '(True, False)',\n        'code': 'foo, bar = True, False',\n    }\n    handle_assign(stmt)\n    # Outputs a formatted Markdown string representing the assign\n    ```\n\n    :param stmt: A dict containing the details of the assign statement.\n    :type stmt: StandardReturn\n    :return: A formatted Markdown string documenting the assign statement.\n    :rtype: str\n    \"\"\"\n    tokens: str = ', '.join(cast(list[str], stmt['tokens']))\n    _type: str = 'Unknown'\n    value: str = cast(str, stmt['value'])\n    _code: str = cast(str, stmt['code'])\n    code: str = indent_code(_code)\n    return ASSIGN_MD_STRUCT.format(token=tokens, _type=_type, value=value, code=code)\n</code></pre>"},{"location":"mosheh/doc.py/#def-_handle_annassign","title":"<code>def _handle_annassign</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>str</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>stmt: StandardReturn</code></p> <p>Kwargs: <code>None</code></p> <p>Generates a Markdown representation for a <code>var: type = value</code> statement.</p> <p>This function processes an annotated assign statement from a parsed Python file, formatting into a structured Markdown block. The output includes the assign name, category, and the indented code snippet.</p> <p>Key concepts:</p> <ul> <li>Import Handling: Extracts the assign statement's details (name, annot, value,   code) and formats them for documentation.</li> <li>Indentation: The <code>indent_code</code> function is used to apply consistent indentation   to the statement code before including it in the Markdown output.</li> <li>MD Struct: The output Markdown uses a predefined template - <code>ASSIGN_MD_STRUCT</code>.</li> </ul> <p>Example:</p> Python<pre><code>stmt: StandardReturn = {\n    'statement': Statement.AnnAssign,\n    'name': 'var',\n    'annot': 'str',\n    'value': '\"example\"',\n    'code': 'var: str = \"example\"',\n}\nhandle_annassign(stmt)\n# Outputs a formatted Markdown string representing the annotated assign\n</code></pre> <p>:param stmt: A dict containing the details of the annassign statement.</p> <p>:type stmt: StandardReturn</p> <p>:return: A formatted Markdown string documenting the annassign statement.</p> <p>:rtype: str</p> SNIPPET Python<pre><code>def _handle_annassign(stmt: StandardReturn) -&gt; str:\n    \"\"\"\n    Generates a Markdown representation for a `var: type = value` statement.\n\n    This function processes an annotated assign statement from a parsed Python file,\n    formatting into a structured Markdown block. The output includes the assign name,\n    category, and the indented code snippet.\n\n    Key concepts:\n    - Import Handling: Extracts the assign statement's details (name, annot, value,\n      code) and formats them for documentation.\n    - Indentation: The `indent_code` function is used to apply consistent indentation\n      to the statement code before including it in the Markdown output.\n    - MD Struct: The output Markdown uses a predefined template - `ASSIGN_MD_STRUCT`.\n\n    Example:\n    ```python\n    stmt: StandardReturn = {\n        'statement': Statement.AnnAssign,\n        'name': 'var',\n        'annot': 'str',\n        'value': '\"example\"',\n        'code': 'var: str = \"example\"',\n    }\n    handle_annassign(stmt)\n    # Outputs a formatted Markdown string representing the annotated assign\n    ```\n\n    :param stmt: A dict containing the details of the annassign statement.\n    :type stmt: StandardReturn\n    :return: A formatted Markdown string documenting the annassign statement.\n    :rtype: str\n    \"\"\"\n    name: str = cast(str, stmt['name'])\n    annot: str = cast(str, stmt['annot'])\n    value: str = cast(str, stmt['value'])\n    _code: str = cast(str, stmt['code'])\n    code: str = indent_code(_code)\n    return ASSIGN_MD_STRUCT.format(token=name, _type=annot, value=value, code=code)\n</code></pre>"},{"location":"mosheh/doc.py/#def-_handle_class_def","title":"<code>def _handle_class_def</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>str</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>stmt: StandardReturn</code></p> <p>Kwargs: <code>None</code></p> <p>Generates a Markdown representation for a <code>class</code> definition statement.</p> <p>This function processes a class definition from a parsed Python codebase, extracting key details such as the class name, inheritance, decorators, keyword arguments, and the code itself. It formats this information into a structured Markdown block for documentation purposes.</p> <p>Key concepts:</p> <ul> <li>Class Handling: Extracts information about the class, including its name,   inheritance hierarchy, and decorators.</li> <li>Indentation: Applies consistent indentation to the class code using the   <code>indent_code</code> function.</li> <li>Markdown Structure: Utilizes a predefined template (<code>CLASS_DEF_MD_STRUCT</code>)   to format the class details in Markdown.</li> </ul> <p>Example:</p> Python<pre><code>stmt: StandardReturn = {\n    'statement': Statement.ClassDef,\n    'name': 'MyClass',\n    'inheritance': ['BaseClass'],\n    'decorators': ['@dataclass'],\n    'kwargs': '',\n    'code': 'class MyClass(BaseClass):',\n}\nhandle_class_def(stmt)\n# Outputs a formatted Markdown string representing the class definition\n</code></pre> <p>:param stmt: A dict containing the details of the class definition statement.</p> <p>:type stmt: StandardReturn</p> <p>:return: A formatted Markdown string documenting the class definition.</p> <p>:rtype: str</p> SNIPPET Python<pre><code>def _handle_class_def(stmt: StandardReturn) -&gt; str:\n    \"\"\"\n    Generates a Markdown representation for a `class` definition statement.\n\n    This function processes a class definition from a parsed Python codebase,\n    extracting key details such as the class name, inheritance, decorators,\n    keyword arguments, and the code itself. It formats this information into\n    a structured Markdown block for documentation purposes.\n\n    Key concepts:\n    - Class Handling: Extracts information about the class, including its name,\n      inheritance hierarchy, and decorators.\n    - Indentation: Applies consistent indentation to the class code using the\n      `indent_code` function.\n    - Markdown Structure: Utilizes a predefined template (`CLASS_DEF_MD_STRUCT`)\n      to format the class details in Markdown.\n\n    Example:\n    ```python\n    stmt: StandardReturn = {\n        'statement': Statement.ClassDef,\n        'name': 'MyClass',\n        'inheritance': ['BaseClass'],\n        'decorators': ['@dataclass'],\n        'kwargs': '',\n        'code': 'class MyClass(BaseClass):',\n    }\n    handle_class_def(stmt)\n    # Outputs a formatted Markdown string representing the class definition\n    ```\n\n    :param stmt: A dict containing the details of the class definition statement.\n    :type stmt: StandardReturn\n    :return: A formatted Markdown string documenting the class definition.\n    :rtype: str\n    \"\"\"\n    name: str = cast(str, stmt['name'])\n    docstring: str | None = cast(str | None, stmt['docstring'])\n    inherit: str = ', '.join(cast(list[str], stmt['inheritance']))\n    decorators: str = ', '.join(cast(list[str], stmt['decorators'])) or 'None'\n    kwargs: str = cast(str, stmt['kwargs'])\n    _code: str = cast(str, stmt['code'])\n    code: str = indent_code(_code)\n    if not docstring:\n        docstring = 'No `docstring` provided.'\n    if not kwargs:\n        kwargs = 'None'\n    return CLASS_DEF_MD_STRUCT.format(name=name, docstring=docstring, inherit=inherit, decorators=decorators, kwargs=kwargs, code=code)\n</code></pre>"},{"location":"mosheh/doc.py/#def-_handle_function_def","title":"<code>def _handle_function_def</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>str</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>stmt: StandardReturn</code></p> <p>Kwargs: <code>None</code></p> <p>Generates a Markdown representation for a function definition statement.</p> <p>This function processes a function or method definition from a parsed Python codebase, extracting details such as the function name, decorators, arguments, keyword arguments, return type, and the code itself. It formats this information into a structured Markdown block for documentation purposes.</p> <p>Key concepts:</p> <ul> <li>Function Handling: Extracts the function's metadata, including decorators,   arguments, and return type.</li> <li>Indentation: Applies consistent indentation to the function code using the   <code>indent_code</code> function.</li> <li>Markdown Structure: Utilizes a predefined template (<code>FUNCTION_DEF_MD_STRUCT</code>)   to format the function details in Markdown.</li> </ul> <p>Example:</p> Python<pre><code>stmt: StandardReturn = {\n    'statement': Statement.FunctionDef,\n    'name': 'sum_thing',\n    'decorators': ['@staticmethod'],\n    'args': [('x', 'int', None), ('y', 'int', None)],\n    'kwargs': [],\n    'rtype': 'int',\n    'code': 'def sum_thing(x: int, y: int) -&gt; int: return x + y',\n}\nhandle_function_def(stmt)\n# Outputs a formatted Markdown string representing the function definition\n</code></pre> <p>:param stmt: A dict containing the details of the function definition statement.</p> <p>:type stmt: StandardReturn</p> <p>:return: A formatted Markdown string documenting the function definition.</p> <p>:rtype: str</p> SNIPPET Python<pre><code>def _handle_function_def(stmt: StandardReturn) -&gt; str:\n    \"\"\"\n    Generates a Markdown representation for a function definition statement.\n\n    This function processes a function or method definition from a parsed Python\n    codebase, extracting details such as the function name, decorators, arguments,\n    keyword arguments, return type, and the code itself. It formats this information\n    into a structured Markdown block for documentation purposes.\n\n    Key concepts:\n    - Function Handling: Extracts the function's metadata, including decorators,\n      arguments, and return type.\n    - Indentation: Applies consistent indentation to the function code using the\n      `indent_code` function.\n    - Markdown Structure: Utilizes a predefined template (`FUNCTION_DEF_MD_STRUCT`)\n      to format the function details in Markdown.\n\n    Example:\n    ```python\n    stmt: StandardReturn = {\n        'statement': Statement.FunctionDef,\n        'name': 'sum_thing',\n        'decorators': ['@staticmethod'],\n        'args': [('x', 'int', None), ('y', 'int', None)],\n        'kwargs': [],\n        'rtype': 'int',\n        'code': 'def sum_thing(x: int, y: int) -&gt; int: return x + y',\n    }\n    handle_function_def(stmt)\n    # Outputs a formatted Markdown string representing the function definition\n    ```\n\n    :param stmt: A dict containing the details of the function definition statement.\n    :type stmt: StandardReturn\n    :return: A formatted Markdown string documenting the function definition.\n    :rtype: str\n    \"\"\"\n    name: str = cast(str, stmt['name'])\n    decorators: str = ', '.join(cast(list[str], stmt['decorators'])) or 'None'\n    category: str = cast(FunctionType, stmt['category']).value\n    docstring: str | None = cast(str | None, stmt['docstring'])\n    args: str = cast(str, stmt['args'])\n    kwargs: str = cast(str, stmt['kwargs'])\n    rtype: str = cast(str, stmt['rtype']) or 'Unknown'\n    _code: str = cast(str, stmt['code'])\n    code: str = indent_code(_code)\n    if not docstring:\n        docstring = 'No `docstring` provided.'\n    if docstring:\n        docstring = docstring.replace(':param', '\\n:param').replace(':type', '\\n:type').replace(':return', '\\n:return').replace(':rtype', '\\n:rtype')\n    if not args:\n        args = 'None'\n    if not kwargs:\n        kwargs = 'None'\n    return FUNCTION_DEF_MD_STRUCT.format(name=name, docstring=docstring, decorators=decorators, category=category, args=args, kwargs=kwargs, rtype=rtype, code=code)\n</code></pre>"},{"location":"mosheh/doc.py/#def-_handle_assert","title":"<code>def _handle_assert</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>str</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>stmt: StandardReturn</code></p> <p>Kwargs: <code>None</code></p> <p>Generates a Markdown representation for an <code>assert x</code> statement.</p> <p>This function processes an assert statement from a parsed Python codebase, extracting the test condition, optional message, and the code itself. It formats this information into a structured Markdown block for documentation purposes.</p> <p>Key concepts:</p> <ul> <li>Assertion Handling: Extracts the test condition and message from the assert   statement.</li> <li>Indentation: Applies consistent indentation to the assert code using the   <code>indent_code</code> function.</li> <li>Markdown Structure: Utilizes a predefined template (<code>ASSERT_MD_STRUCT</code>)   to format the assertion details in Markdown.</li> </ul> <p>Example:</p> Python<pre><code>stmt: StandardReturn = {\n    'statement': Statement.Assert,\n    'test': 'x &gt; 0',\n    'msg': '\"x must be positive\"',\n    'code': 'assert x &gt; 0, \"x must be positive\"',\n}\nhandle_assert(stmt)\n# Outputs a formatted Markdown string representing the assert statement\n</code></pre> <p>:param stmt: A dictionary containing the details of the assert statement.</p> <p>:type stmt: StandardReturn</p> <p>:return: A formatted Markdown string documenting the assert statement.</p> <p>:rtype: str</p> SNIPPET Python<pre><code>def _handle_assert(stmt: StandardReturn) -&gt; str:\n    \"\"\"\n    Generates a Markdown representation for an `assert x` statement.\n\n    This function processes an assert statement from a parsed Python codebase,\n    extracting the test condition, optional message, and the code itself. It formats\n    this information into a structured Markdown block for documentation purposes.\n\n    Key concepts:\n    - Assertion Handling: Extracts the test condition and message from the assert\n      statement.\n    - Indentation: Applies consistent indentation to the assert code using the\n      `indent_code` function.\n    - Markdown Structure: Utilizes a predefined template (`ASSERT_MD_STRUCT`)\n      to format the assertion details in Markdown.\n\n    Example:\n    ```python\n    stmt: StandardReturn = {\n        'statement': Statement.Assert,\n        'test': 'x &gt; 0',\n        'msg': '\"x must be positive\"',\n        'code': 'assert x &gt; 0, \"x must be positive\"',\n    }\n    handle_assert(stmt)\n    # Outputs a formatted Markdown string representing the assert statement\n    ```\n\n    :param stmt: A dictionary containing the details of the assert statement.\n    :type stmt: StandardReturn\n    :return: A formatted Markdown string documenting the assert statement.\n    :rtype: str\n    \"\"\"\n    test: str = cast(str, stmt['test'])\n    msg: str = cast(str, stmt['msg'])\n    _code: str = cast(str, stmt['code'])\n    code: str = indent_code(_code)\n    return ASSERT_MD_STRUCT.format(test=test, msg=msg, code=code)\n</code></pre>"},{"location":"mosheh/doc.py/#def-_process_codebase","title":"<code>def _process_codebase</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>None</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>codebase: dict[str, CodebaseDict] | dict[str, list[StandardReturn]], root: str, exit: str, basedir: str</code></p> <p>Kwargs: <code>None</code></p> <p>Recursively processes a codebase and generates documentation for each file.</p> <p>This function traverses a codebase structure, processes each file's statements, and generates corresponding Markdown documentation. The documentation is written to the specified output directory. If the codebase contains nested dictionaries, the function recursively processes each nested level.</p> <p>Key concepts:</p> <ul> <li>Recursive Processing: Handles both individual files and nested dirs.</li> <li>File Documentation: Converts statements into documentation and writes to output.</li> <li>Directory Structure: Preserves directory structure in the output documentation.</li> </ul> <p>Example:</p> Python<pre><code>process_codebase(codebase, '/root', '/output')\n# Processes the codebase and generates documentation in the '/output' directory.\n</code></pre> <p>:param codebase: The codebase to process, which can contain files or nested dirs.</p> <p>:type codebase: dict[str, CodebaseDict] | dict[str, list[StandardReturn]]</p> <p>:param root: The root directory of the project.</p> <p>:type root: str</p> <p>:param exit: The output directory where documentation will be saved.</p> <p>:type exit: str</p> <p>:param basedir: The base directory used during the recursive traversal.</p> <p>:type basedir: str</p> <p>:return: None.</p> <p>:rtype: None</p> SNIPPET Python<pre><code>def _process_codebase(codebase: dict[str, CodebaseDict] | dict[str, list[StandardReturn]], root: str, exit: str, basedir: str='') -&gt; None:\n    \"\"\"\n    Recursively processes a codebase and generates documentation for each file.\n\n    This function traverses a codebase structure, processes each file's statements,\n    and generates corresponding Markdown documentation. The documentation is written\n    to the specified output directory. If the codebase contains nested dictionaries,\n    the function recursively processes each nested level.\n\n    Key concepts:\n    - Recursive Processing: Handles both individual files and nested dirs.\n    - File Documentation: Converts statements into documentation and writes to output.\n    - Directory Structure: Preserves directory structure in the output documentation.\n\n    Example:\n    ```python\n    process_codebase(codebase, '/root', '/output')\n    # Processes the codebase and generates documentation in the '/output' directory.\n    ```\n\n    :param codebase: The codebase to process, which can contain files or nested dirs.\n    :type codebase: dict[str, CodebaseDict] | dict[str, list[StandardReturn]]\n    :param root: The root directory of the project.\n    :type root: str\n    :param exit: The output directory where documentation will be saved.\n    :type exit: str\n    :param basedir: The base directory used during the recursive traversal.\n    :type basedir: str\n    :return: None.\n    :rtype: None\n    \"\"\"\n    parents: list[str] = list(codebase.keys())\n    docs_path: str = path.join(exit, 'docs')\n    logger.debug('\"parents: list[str]\" and \"docs_path: str\" defined')\n    for key in parents:\n        logger.debug(f'Evaluating {key} of {parents}')\n        value = codebase[key]\n        new_path: str = path.join(basedir, key)\n        if isinstance(value, list):\n            logger.debug(f'Processing file {key}')\n            _process_file(key, value, new_path, root, docs_path)\n        else:\n            _process_codebase(value, root, exit, new_path)\n</code></pre>"},{"location":"mosheh/doc.py/#def-_process_file","title":"<code>def _process_file</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>None</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>key: str, stmts: list[StandardReturn], file_path: str, root: str, docs_path: str</code></p> <p>Kwargs: <code>None</code></p> <p>Processes a file's stmts and generates corresponding documentation.</p> <p>This function converts a list of stmts into a Markdown document, writes the content to the appropriate file path, and updates the navigation structure for the documentation. If the necessary folder path does not exist, it is created.</p> <p>Key concepts:</p> <ul> <li>Statement Processing: Converts stmts into Markdown format.</li> <li>File Writing: Saves the generated content to the appropriate file.</li> <li>Navigation Update: Updates the documentation's navigation structure.</li> </ul> <p>Example:</p> Python<pre><code>__process_file('module_name', stmts, 'src/module.py', '/root', '/docs')\n# Processes the stmts from 'module.py' and generates corresponding markdown docs.\n</code></pre> <p>:param key: The key representing the module or file being processed.</p> <p>:type key: str</p> <p>:param stmts: The list of stmts that represent the code to be documented.</p> <p>:type stmts: list[StandardReturn]</p> <p>:param file_path: The path to the source file, used to derive output locations.</p> <p>:type file_path: str</p> <p>:param root: The root directory of the project.</p> <p>:type root: str</p> <p>:param docs_path: The path to the documentation directory.</p> <p>:type docs_path: str</p> <p>:return: None.</p> <p>:rtype: None</p> SNIPPET Python<pre><code>def _process_file(key: str, stmts: list[StandardReturn], file_path: str, root: str, docs_path: str) -&gt; None:\n    \"\"\"\n    Processes a file's stmts and generates corresponding documentation.\n\n    This function converts a list of stmts into a Markdown document, writes\n    the content to the appropriate file path, and updates the navigation structure\n    for the documentation. If the necessary folder path does not exist, it is created.\n\n    Key concepts:\n    - Statement Processing: Converts stmts into Markdown format.\n    - File Writing: Saves the generated content to the appropriate file.\n    - Navigation Update: Updates the documentation's navigation structure.\n\n    Example:\n    ```python\n    __process_file('module_name', stmts, 'src/module.py', '/root', '/docs')\n    # Processes the stmts from 'module.py' and generates corresponding markdown docs.\n    ```\n\n    :param key: The key representing the module or file being processed.\n    :type key: str\n    :param stmts: The list of stmts that represent the code to be documented.\n    :type stmts: list[StandardReturn]\n    :param file_path: The path to the source file, used to derive output locations.\n    :type file_path: str\n    :param root: The root directory of the project.\n    :type root: str\n    :param docs_path: The path to the documentation directory.\n    :type docs_path: str\n    :return: None.\n    :rtype: None\n    \"\"\"\n    if not stmts:\n        logger.debug(f'{key} empty, has no statement')\n        return\n    content: str = _codebase_to_markdown(stmts, file_path)\n    output_file_path: str = path.join(docs_path, 'Codebase', file_path.removeprefix(root) + '.md')\n    folder_path: str = path.dirname(output_file_path)\n    if not path.exists(path.join('.', folder_path)):\n        makedirs(path.join('.', folder_path))\n        logger.debug(f'{folder_path} created')\n    _write_to_file(output_file_path, content)\n    _update_navigation(folder_path, docs_path, key, output_file_path)\n</code></pre>"},{"location":"mosheh/doc.py/#def-_write_to_file","title":"<code>def _write_to_file</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>None</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>file_path: str, content: str</code></p> <p>Kwargs: <code>None</code></p> <p>Writes content to a specified file.</p> <p>This function opens a file at the given path in write mode and writes the provided content to it. The content is written using UTF-8 encoding, ensuring compatibility with various char sets.</p> <p>Key concepts:</p> <ul> <li>File Writing: Opens a file for writing and writes the content.</li> <li>UTF-8 Encoding: Ensures the file is written with UTF-8 for proper char handling.</li> </ul> <p>Example:</p> Python<pre><code>__write_to_file('output.md', 'This is some content.')\n# Writes the content \"This is some content.\" to 'output.md'.\n</code></pre> <p>:param file_path: The path to the file where the content will be written.</p> <p>:type file_path: str</p> <p>:param content: The content to be written to the file.</p> <p>:type content: str</p> <p>:return: None.</p> <p>:rtype: None</p> SNIPPET Python<pre><code>def _write_to_file(file_path: str, content: str) -&gt; None:\n    \"\"\"\n    Writes content to a specified file.\n\n    This function opens a file at the given path in write mode and writes the provided\n    content to it. The content is written using UTF-8 encoding, ensuring compatibility\n    with various char sets.\n\n    Key concepts:\n    - File Writing: Opens a file for writing and writes the content.\n    - UTF-8 Encoding: Ensures the file is written with UTF-8 for proper char handling.\n\n    Example:\n    ```python\n    __write_to_file('output.md', 'This is some content.')\n    # Writes the content \"This is some content.\" to 'output.md'.\n    ```\n\n    :param file_path: The path to the file where the content will be written.\n    :type file_path: str\n    :param content: The content to be written to the file.\n    :type content: str\n    :return: None.\n    :rtype: None\n    \"\"\"\n    with open(path.join('.', file_path), 'w', encoding='utf-8') as file:\n        file.write(content)\n        logger.debug(f'Content written to {file_path}')\n</code></pre>"},{"location":"mosheh/doc.py/#def-_update_navigation","title":"<code>def _update_navigation</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>None</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>folder_path: str, docs_path: str, key: str, output_file_path: str</code></p> <p>Kwargs: <code>None</code></p> <p>Updates the navigation structure for documentation generation.</p> <p>This function builds and updates a nested navigation structure for documentation files based on the provided folder path and file location. It ensures that each segment of the path is represented in the navigation hierarchy, maintaining the correct indentation levels.</p> <p>Key concepts:</p> <ul> <li>Navigation Hierarchy: Constructs a structured navigation tree from folder paths.</li> <li>Indentation: Adjusts indentation dynamically based on folder depth.</li> <li>Path Normalization: Handles path manipulation to generate correct relative paths.</li> </ul> <p>Example:</p> Python<pre><code>__update_navigation(\n    'project/docs/module',\n    'project/docs',\n    'functions',\n    'project/docs/module/functions.md',\n)\n# Updates the global NAV_DIRS and NAV_MD structs with the right navigation entries.\n</code></pre> <p>:param folder_path: The full path to the folder containing the documentation files.</p> <p>:type folder_path: str</p> <p>:param docs_path: The root path to the documentation directory.</p> <p>:type docs_path: str</p> <p>:param key: The label or name for the current documentation entry.</p> <p>:type key: str</p> <p>:param output_file_path: The path to the output documentation file.</p> <p>:type output_file_path: str</p> <p>:return: None.</p> <p>:rtype: None</p> SNIPPET Python<pre><code>def _update_navigation(folder_path: str, docs_path: str, key: str, output_file_path: str) -&gt; None:\n    \"\"\"\n    Updates the navigation structure for documentation generation.\n\n    This function builds and updates a nested navigation structure for documentation\n    files based on the provided folder path and file location. It ensures that\n    each segment of the path is represented in the navigation hierarchy, maintaining\n    the correct indentation levels.\n\n    Key concepts:\n    - Navigation Hierarchy: Constructs a structured navigation tree from folder paths.\n    - Indentation: Adjusts indentation dynamically based on folder depth.\n    - Path Normalization: Handles path manipulation to generate correct relative paths.\n\n    Example:\n    ```python\n    __update_navigation(\n        'project/docs/module',\n        'project/docs',\n        'functions',\n        'project/docs/module/functions.md',\n    )\n    # Updates the global NAV_DIRS and NAV_MD structs with the right navigation entries.\n    ```\n\n    :param folder_path: The full path to the folder containing the documentation files.\n    :type folder_path: str\n    :param docs_path: The root path to the documentation directory.\n    :type docs_path: str\n    :param key: The label or name for the current documentation entry.\n    :type key: str\n    :param output_file_path: The path to the output documentation file.\n    :type output_file_path: str\n    :return: None.\n    :rtype: None\n    \"\"\"\n    nav_path: list[str] = [segment for segment in folder_path.removeprefix(docs_path).split(path.sep) if segment]\n    logger.debug('\"nav_path: list[str]\" created')\n    if not nav_path:\n        md_file_path: str = output_file_path.removeprefix(docs_path + path.sep)\n        md_line: str = indent_code(f'- {key}: {md_file_path}', 2)\n        NAV_MD.append(f'{md_line}\\n')\n        logger.debug('\"NAV_MD\" updated with no \"nav_path\"')\n        return\n    for i in range(len(nav_path)):\n        sub_nav_path: str = path.sep.join(nav_path[:i + 1])\n        if sub_nav_path not in NAV_DIRS:\n            NAV_DIRS.append(sub_nav_path)\n            md_line: str = indent_code(f'- {nav_path[i]}:', 2 * (i + 1))\n            NAV_MD.append(f'{md_line}\\n')\n            logger.debug('\"NAV_MD\" updated with path not in \"NAV_DIRS\"')\n        if i + 1 == len(nav_path):\n            md_file_path: str = output_file_path.removeprefix(docs_path + path.sep)\n            md_line: str = indent_code(f'- {key}: {md_file_path}', 2 * (i + 2))\n            NAV_MD.append(f'{md_line}\\n')\n            logger.debug('\"NAV_MD\" updated')\n</code></pre>"},{"location":"mosheh/doc.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"mosheh/handler.py/","title":"File: <code>handler.py</code>","text":"<p>Role: Python Source Code</p> <p>Path: <code>mosheh</code></p> <p>Being the longest file, this one's role is process the source codebase.</p> <p>By calling <code>handle_def_nodes</code> with an <code>ast.AST</code> node, it's going to parse the node type and call the right handle func. The defined nodes are <code>ast.Import</code>, <code>ast.ImportFrom</code>, <code>ast.Assign</code>, <code>ast.AnnAssign</code>, <code>ast.FunctionDef</code>, <code>ast.AsyncFunctionDef</code>, <code>ast.ClassDef</code> and <code>ast.Assert</code>; if more nodes inside them, <code>_handle_node</code> is called to process the new one.</p>"},{"location":"mosheh/handler.py/#imports","title":"Imports","text":""},{"location":"mosheh/handler.py/#import-ast","title":"<code>import ast</code>","text":"<p>Path: <code>None</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>import ast\n</code></pre>"},{"location":"mosheh/handler.py/#import-logger","title":"<code>import Logger</code>","text":"<p>Path: <code>logging</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from logging import Logger\n</code></pre>"},{"location":"mosheh/handler.py/#import-getlogger","title":"<code>import getLogger</code>","text":"<p>Path: <code>logging</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from logging import getLogger\n</code></pre>"},{"location":"mosheh/handler.py/#import-final","title":"<code>import Final</code>","text":"<p>Path: <code>typing</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from typing import Final\n</code></pre>"},{"location":"mosheh/handler.py/#import-cast","title":"<code>import cast</code>","text":"<p>Path: <code>typing</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from typing import cast\n</code></pre>"},{"location":"mosheh/handler.py/#import-constants","title":"<code>import constants</code>","text":"<p>Path: <code>None</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from None import constants\n</code></pre>"},{"location":"mosheh/handler.py/#import-functiontype","title":"<code>import FunctionType</code>","text":"<p>Path: <code>custom_types</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from custom_types import FunctionType\n</code></pre>"},{"location":"mosheh/handler.py/#import-importtype","title":"<code>import ImportType</code>","text":"<p>Path: <code>custom_types</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from custom_types import ImportType\n</code></pre>"},{"location":"mosheh/handler.py/#import-standardreturn","title":"<code>import StandardReturn</code>","text":"<p>Path: <code>custom_types</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from custom_types import StandardReturn\n</code></pre>"},{"location":"mosheh/handler.py/#import-standardreturnprocessor","title":"<code>import StandardReturnProcessor</code>","text":"<p>Path: <code>custom_types</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from custom_types import StandardReturnProcessor\n</code></pre>"},{"location":"mosheh/handler.py/#import-statement","title":"<code>import Statement</code>","text":"<p>Path: <code>custom_types</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from custom_types import Statement\n</code></pre>"},{"location":"mosheh/handler.py/#import-bin","title":"<code>import bin</code>","text":"<p>Path: <code>utils</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from utils import bin\n</code></pre>"},{"location":"mosheh/handler.py/#import-is_lib_installed","title":"<code>import is_lib_installed</code>","text":"<p>Path: <code>utils</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from utils import is_lib_installed\n</code></pre>"},{"location":"mosheh/handler.py/#import-standard_struct","title":"<code>import standard_struct</code>","text":"<p>Path: <code>utils</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from utils import standard_struct\n</code></pre>"},{"location":"mosheh/handler.py/#consts","title":"Consts","text":"<p>NO CONSTANT DEFINED HERE</p>"},{"location":"mosheh/handler.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"mosheh/handler.py/#functions","title":"Functions","text":""},{"location":"mosheh/handler.py/#def-handle_def_nodes","title":"<code>def handle_def_nodes</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturn]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>node: ast.AST</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an abstract syntax tree (AST) node and returns a handler for the node.</p> <p>This function analyzes a given <code>ast.AST</code> node, determines its type, and processes it using the appropriate handler function. It supports a variety of node types such as imports, constants, functions, classes, and assertions, delegating the handling to specialized functions for each case.</p> <p>The function categorizes and handles nodes as follows:</p> <ul> <li>Imports: <code>ast.Import | ast.ImportFrom</code></li> <li>Constants: <code>ast.Assign | ast.AnnAssign</code></li> <li>Functions: <code>ast.FunctionDef | ast.AsyncFunctionDef</code></li> <li>Classes: <code>ast.ClassDef</code></li> <li>Assertions: <code>ast.Assert</code></li> </ul> <p>:param node: The AST node to process.</p> <p>:type node: ast.AST</p> <p>:return: An object containing information associated with the node.</p> <p>:rtype: list[StandardReturn]</p> SNIPPET Python<pre><code>def handle_def_nodes(node: ast.AST) -&gt; list[StandardReturn]:\n    \"\"\"\n    Processes an abstract syntax tree (AST) node and returns a handler for the node.\n\n    This function analyzes a given `ast.AST` node, determines its type, and processes\n    it using the appropriate handler function. It supports a variety of node types such\n    as imports, constants, functions, classes, and assertions, delegating the handling\n    to specialized functions for each case.\n\n    The function categorizes and handles nodes as follows:\n    - Imports: `ast.Import | ast.ImportFrom`\n    - Constants: `ast.Assign | ast.AnnAssign`\n    - Functions: `ast.FunctionDef | ast.AsyncFunctionDef`\n    - Classes: `ast.ClassDef`\n    - Assertions: `ast.Assert`\n\n    :param node: The AST node to process.\n    :type node: ast.AST\n    :return: An object containing information associated with the node.\n    :rtype: list[StandardReturn]\n    \"\"\"\n    data: list[StandardReturn] = []\n    logger.debug('\"data: list[StandardReturn]\" created')\n    if isinstance(node, ast.Import):\n        data = _handle_import(data, node)\n    elif isinstance(node, ast.ImportFrom):\n        data = _handle_import_from(data, node)\n    elif isinstance(node, ast.Assign):\n        lst: list[str] = []\n        for i in node.targets:\n            lst.extend(cast(list[str], _handle_node(i)))\n        if any(map(str.isupper, lst)) or any(map(lambda x: bin(x, constants.ACCEPTABLE_LOWER_CONSTANTS), lst)):\n            data = _handle_assign(data, node)\n    elif isinstance(node, ast.AnnAssign):\n        if isinstance(node.target, ast.Name) and node.target.id.isupper():\n            data = _handle_annassign(data, node)\n    elif isinstance(node, ast.FunctionDef):\n        data = _handle_function_def(data, node)\n    elif isinstance(node, ast.AsyncFunctionDef):\n        data = _handle_async_function_def(data, node)\n    elif isinstance(node, ast.ClassDef):\n        data = _handle_class_def(data, node)\n    elif isinstance(node, ast.Assert):\n        data = _handle_assert(data, node)\n    logger.debug('Returning \"data\"')\n    return data\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_node","title":"<code>def _handle_node</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor] | None</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>node: ast.AST | ast.expr | None</code></p> <p>Kwargs: <code>None</code></p> <p>Processes various types of AST nodes and returns a standardized representation.</p> <p>This function extends the capabilities of <code>handle_def_nodes()</code> by supporting a wider range of Python Abstract Syntax Tree (AST) node types. It identifies the node type, delegates processing to the appropriate handler function, and accumulates the results into a standardized format.</p> <p>Key concepts:</p> <ul> <li>AST Parsing: Supports multiple node types (e.g., imports, functions, classes,   constants).</li> <li>Dynamic Dispatch: Uses type-checking to delegate node handling to specific   functions (e.g., <code>handle_import</code>, <code>handle_function_def</code>).</li> <li>Data Standardization: Accumulates processed data into a consistent structure   (<code>StandardReturnProcessor</code>).</li> </ul> <p>Example:</p> Python<pre><code>import ast\n\nsource_code = 'def my_function():\\n    pass'\nnode: ast.AST = ast.parse(source_code).body[0]\nhandle_node(node)\n# Outputs a standardized representation of the function definition.\n</code></pre> <p>:param node: The AST node to be processed.</p> <p>:type node: ast.AST | ast.expr | None</p> <p>:return: A list of standardized data representing the processed node, or <code>None</code> if no node is provided.</p> <p>:rtype: list[StandardReturnProcessor] | None</p> SNIPPET Python<pre><code>def _handle_node(node: ast.AST | ast.expr | None) -&gt; list[StandardReturnProcessor] | None:\n    \"\"\"\n    Processes various types of AST nodes and returns a standardized representation.\n\n    This function extends the capabilities of `handle_def_nodes()` by supporting a\n    wider range of Python Abstract Syntax Tree (AST) node types. It identifies the\n    node type, delegates processing to the appropriate handler function, and\n    accumulates the results into a standardized format.\n\n    Key concepts:\n    - AST Parsing: Supports multiple node types (e.g., imports, functions, classes,\n      constants).\n    - Dynamic Dispatch: Uses type-checking to delegate node handling to specific\n      functions (e.g., `handle_import`, `handle_function_def`).\n    - Data Standardization: Accumulates processed data into a consistent structure\n      (`StandardReturnProcessor`).\n\n    Example:\n    ```python\n    import ast\n\n    source_code = 'def my_function():\\\\n    pass'\n    node: ast.AST = ast.parse(source_code).body[0]\n    handle_node(node)\n    # Outputs a standardized representation of the function definition.\n    ```\n\n    :param node: The AST node to be processed.\n    :type node: ast.AST | ast.expr | None\n    :return: A list of standardized data representing the processed node, or `None` if\n                no node is provided.\n    :rtype: list[StandardReturnProcessor] | None\n    \"\"\"\n    if node is None:\n        return node\n    data: list[StandardReturnProcessor] = []\n\n    def update_data(new_data: list[StandardReturn]):\n        nonlocal data\n        data = cast(list[StandardReturnProcessor], new_data)\n    if isinstance(node, ast.Import):\n        update_data(_handle_import(cast(list[StandardReturn], data), node))\n    elif isinstance(node, ast.ImportFrom):\n        update_data(_handle_import_from(cast(list[StandardReturn], data), node))\n    elif isinstance(node, ast.Assign):\n        lst: list[str] = [cast(list[str], _handle_constant([], i))[0] for i in node.targets if isinstance(i, ast.Constant)]\n        if any(map(str.isupper, lst)):\n            update_data(_handle_assign(cast(list[StandardReturn], data), node))\n    elif isinstance(node, ast.AnnAssign):\n        if isinstance(node.target, ast.Name) and node.target.id.isupper():\n            update_data(_handle_annassign(cast(list[StandardReturn], data), node))\n    elif isinstance(node, ast.FunctionDef):\n        update_data(_handle_function_def(cast(list[StandardReturn], data), node))\n    elif isinstance(node, ast.AsyncFunctionDef):\n        update_data(_handle_async_function_def(cast(list[StandardReturn], data), node))\n    elif isinstance(node, ast.ClassDef):\n        update_data(_handle_class_def(cast(list[StandardReturn], data), node))\n    elif isinstance(node, ast.Assert):\n        update_data(_handle_assert(cast(list[StandardReturn], data), node))\n    elif isinstance(node, ast.Call):\n        data = _handle_call(data, node)\n    elif isinstance(node, ast.Constant):\n        data = _handle_constant(data, node)\n    elif isinstance(node, ast.Attribute):\n        data = _handle_attribute(data, node)\n    elif isinstance(node, ast.List):\n        data = _handle_list(data, node)\n    elif isinstance(node, ast.Tuple):\n        data = _handle_tuple(data, node)\n    elif isinstance(node, ast.Set):\n        data = _handle_set(data, node)\n    elif isinstance(node, ast.Dict):\n        data = _handle_dict(data, node)\n    elif isinstance(node, ast.BinOp):\n        data = _handle_binop(data, node)\n    elif isinstance(node, ast.UnaryOp):\n        data = _handle_unary(data, node)\n    elif isinstance(node, ast.Subscript):\n        data = _handle_subscript(data, node)\n    elif isinstance(node, ast.Slice):\n        data = _handle_slice(data, node)\n    elif isinstance(node, ast.Name):\n        data = _handle_name(data, node)\n    elif isinstance(node, ast.Load):\n        data = _handle_load(data, node)\n    elif isinstance(node, ast.Store):\n        data = _handle_store(data, node)\n    elif isinstance(node, ast.Del):\n        data = _handle_del(data, node)\n    elif isinstance(node, ast.Delete):\n        data = _handle_delete(data, node)\n    elif isinstance(node, ast.Starred):\n        data = _handle_starred(data, node)\n    elif isinstance(node, ast.Compare):\n        data = _handle_compare(data, node)\n    elif isinstance(node, ast.JoinedStr):\n        data = _handle_joined_str(data, node)\n    elif isinstance(node, ast.FormattedValue):\n        data = _handle_formatted_value(data, node)\n    elif isinstance(node, ast.IfExp):\n        data = _handle_if_expression(data, node)\n    elif isinstance(node, ast.BoolOp):\n        data = _handle_bool_op(data, node)\n    elif isinstance(node, ast.ListComp | ast.DictComp | ast.SetComp | ast.GeneratorExp):\n        data = _handle_comprehensions(data, node)\n    elif isinstance(node, ast.Lambda):\n        data = _handle_lambda(data, node)\n    elif isinstance(node, ast.Await):\n        data = _handle_await(data, node)\n    elif isinstance(node, ast.AsyncFor):\n        data = _handle_async_for(data, node)\n    elif isinstance(node, ast.AsyncWith):\n        data = _handle_async_with(data, node)\n    elif isinstance(node, ast.Global):\n        data = _handle_global(data, node)\n    elif isinstance(node, ast.Nonlocal):\n        data = _handle_nonlocal(data, node)\n    elif isinstance(node, ast.Return):\n        data = _handle_return(data, node)\n    elif isinstance(node, ast.Yield):\n        data = _handle_yield(data, node)\n    elif isinstance(node, ast.YieldFrom):\n        data = _handle_yield_from(data, node)\n    elif isinstance(node, ast.Try):\n        data = _handle_try(data, node)\n    elif isinstance(node, ast.TryStar):\n        data = _handle_try_star(data, node)\n    elif isinstance(node, ast.ExceptHandler):\n        data = _handle_except_handler(data, node)\n    elif isinstance(node, ast.Raise):\n        data = _handle_raise(data, node)\n    elif isinstance(node, ast.TypeVar):\n        data = _handle_type_var(data, node)\n    elif isinstance(node, ast.ParamSpec):\n        data = _handle_param_spec(data, node)\n    elif isinstance(node, ast.TypeVarTuple):\n        data = _handle_type_var_tuple(data, node)\n    elif isinstance(node, ast.TypeAlias):\n        data = _handle_type_alias(data, node)\n    elif isinstance(node, ast.Match):\n        data = _handle_match(data, node)\n    elif isinstance(node, ast.With):\n        data = _handle_with(data, node)\n    elif isinstance(node, ast.For):\n        data = _handle_for(data, node)\n    elif isinstance(node, ast.While):\n        data = _handle_while(data, node)\n    elif isinstance(node, ast.Break):\n        data = _handle_break(data, node)\n    elif isinstance(node, ast.Continue):\n        data = _handle_continue(data, node)\n    elif isinstance(node, ast.If):\n        data = _handle_if(data, node)\n    elif isinstance(node, ast.Pass):\n        data = _handle_pass(data, node)\n    elif isinstance(node, ast.NamedExpr):\n        data = _handle_named_expr(data, node)\n    elif isinstance(node, ast.Expr):\n        data = _handle_expr(data, node)\n    elif isinstance(node, ast.AugAssign):\n        data = _handle_augassign(data, node)\n    return data\n</code></pre>"},{"location":"mosheh/handler.py/#def-__handle_import","title":"<code>def __handle_import</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>StandardReturn</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>lib_name: str</code></p> <p>Kwargs: <code>None</code></p> <p>Constructs a standardized dictionary representation for an import statement.</p> <p>This function processes the given library name, determines its import category (local, native, or third-party), and builds a standardized dictionary structure representing the import statement. The resulting data includes information about the statement type, library name, import category, and the generated import code.</p> <p>Key concepts:</p> <ul> <li>Import Categorization: Determines whether the library is native (built-in),   third-party, or local.</li> <li>Standardized Structure: Returns a dictionary conforming to the <code>StandardReturn</code>   format, ensuring consistency across codebase documentation.</li> <li>Dynamic Code Generation: Constructs the import statement dynamically based on   the library name.</li> </ul> <p>Example:</p> Python<pre><code>data: StandardReturn = __handle_import('os')\ndata\n# {\n#     'statement': Statement.Import,\n#     'name': 'os',\n#     'path': None,\n#     'category': ImportType.Native,\n#     'code': 'import os',\n# }\n</code></pre> <p>:param lib_name: The name of the library to be imported.</p> <p>:type lib_name: str</p> <p>:return: A standardized dictionary representing the import statement.</p> <p>:rtype: list[StandardReturn]</p> SNIPPET Python<pre><code>def __handle_import(lib_name: str) -&gt; StandardReturn:\n    \"\"\"\n    Constructs a standardized dictionary representation for an import statement.\n\n    This function processes the given library name, determines its import category\n    (local, native, or third-party), and builds a standardized dictionary structure\n    representing the import statement. The resulting data includes information about\n    the statement type, library name, import category, and the generated import code.\n\n    Key concepts:\n    - Import Categorization: Determines whether the library is native (built-in),\n      third-party, or local.\n    - Standardized Structure: Returns a dictionary conforming to the `StandardReturn`\n      format, ensuring consistency across codebase documentation.\n    - Dynamic Code Generation: Constructs the import statement dynamically based on\n      the library name.\n\n    Example:\n    ```python\n    data: StandardReturn = __handle_import('os')\n    data\n    # {\n    #     'statement': Statement.Import,\n    #     'name': 'os',\n    #     'path': None,\n    #     'category': ImportType.Native,\n    #     'code': 'import os',\n    # }\n    ```\n\n    :param lib_name: The name of the library to be imported.\n    :type lib_name: str\n    :return: A standardized dictionary representing the import statement.\n    :rtype: list[StandardReturn]\n    \"\"\"\n    statement: Statement = Statement.Import\n    path: Final[None] = None\n    category: ImportType = ImportType.Local\n    if bin(lib_name, constants.BUILTIN_MODULES):\n        category = ImportType.Native\n    elif is_lib_installed(lib_name):\n        category = ImportType.TrdParty\n    data: StandardReturn = standard_struct()\n    data.update({'statement': statement, 'name': lib_name, 'path': path, 'category': category, 'code': f'import {lib_name}'})\n    return data\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_import","title":"<code>def _handle_import</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturn]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturn], node: ast.Import</code></p> <p>Kwargs: <code>None</code></p> <p>Updates a standardized structure with information from an import statement node.</p> <p>This function processes an AST import node, extracts the library names being imported, and updates the given <code>StandardReturn</code> structure with details about each library. It leverages the <code>__handle_import</code> function to standardize the data for each imported library.</p> <p>Key concepts:</p> <ul> <li>AST Parsing: Processes Python's AST nodes for import statements.</li> <li>Data Standardization: Utilizes <code>__handle_import</code> to format each import into a   consistent structure.</li> <li>Structure Update: Modifies the provided <code>struct</code> in-place with import data.</li> </ul> <p>Example:</p> Python<pre><code>struct: dict = standard_struct()\nnode: ast.AST = ast.parse('import os, sys').body[0]\nupdated_struct: dict = _handle_import(struct, node)\nupdated_struct\n# Outputs standardized data for `os` and `sys` imports.\n</code></pre> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturn]</p> <p>:param node: The AST node representing an import statement.</p> <p>:type node: ast.Import</p> <p>:return: The updated structure with information about the imported libraries.</p> <p>:rtype: list[StandardReturn]</p> SNIPPET Python<pre><code>def _handle_import(struct: list[StandardReturn], node: ast.Import) -&gt; list[StandardReturn]:\n    \"\"\"\n    Updates a standardized structure with information from an import statement node.\n\n    This function processes an AST import node, extracts the library names being\n    imported, and updates the given `StandardReturn` structure with details about\n    each library. It leverages the `__handle_import` function to standardize the data\n    for each imported library.\n\n    Key concepts:\n    - AST Parsing: Processes Python's AST nodes for import statements.\n    - Data Standardization: Utilizes `__handle_import` to format each import into a\n      consistent structure.\n    - Structure Update: Modifies the provided `struct` in-place with import data.\n\n    Example:\n    ```python\n    struct: dict = standard_struct()\n    node: ast.AST = ast.parse('import os, sys').body[0]\n    updated_struct: dict = _handle_import(struct, node)\n    updated_struct\n    # Outputs standardized data for `os` and `sys` imports.\n    ```\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturn]\n    :param node: The AST node representing an import statement.\n    :type node: ast.Import\n    :return: The updated structure with information about the imported libraries.\n    :rtype: list[StandardReturn]\n    \"\"\"\n    for lib in [i.name for i in node.names]:\n        struct.append(__handle_import(lib))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_import_from","title":"<code>def _handle_import_from</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturn]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturn], node: ast.ImportFrom</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.ImportFrom</code> node and returnes its data.</p> <p>This function iterates over the imported module names within an <code>ast.ImportFrom</code> node, classifying each module into one of the following categorys, as <code>handle_import</code>:</p> <ul> <li>Native: The module is a built-in Python module.</li> <li>Third-Party: The module is installed via external libraries.</li> <li>Local: The module is neither built-in nor a third-party library, problably local.</li> </ul> <p>Each module's data includes its path and category, stored in a structured dict.</p> <p>Example:</p> Python<pre><code>struct: dict = standard_struct()\nnode: ast.AST = ast.parse('from os import environ').body[0]\nupdated_struct: dict = _handle_import_from(struct, node)\nupdated_struct\n# Outputs standardized data for `environ` with `os` as path.\n</code></pre> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturn]</p> <p>:param node: The AST node representing an import statement.</p> <p>:type node: ast.ImportFrom</p> <p>:return: A dict containing the statement type and categorized module information.</p> <p>:rtype: list[StandardReturn]</p> SNIPPET Python<pre><code>def _handle_import_from(struct: list[StandardReturn], node: ast.ImportFrom) -&gt; list[StandardReturn]:\n    \"\"\"\n    Processes an `ast.ImportFrom` node and returnes its data.\n\n    This function iterates over the imported module names within an `ast.ImportFrom`\n    node, classifying each module into one of the following categorys, as\n    `handle_import`:\n    - Native: The module is a built-in Python module.\n    - Third-Party: The module is installed via external libraries.\n    - Local: The module is neither built-in nor a third-party library, problably local.\n\n    Each module's data includes its path and category, stored in a structured dict.\n\n    Example:\n    ```python\n    struct: dict = standard_struct()\n    node: ast.AST = ast.parse('from os import environ').body[0]\n    updated_struct: dict = _handle_import_from(struct, node)\n    updated_struct\n    # Outputs standardized data for `environ` with `os` as path.\n    ```\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturn]\n    :param node: The AST node representing an import statement.\n    :type node: ast.ImportFrom\n    :return: A dict containing the statement type and categorized module information.\n    :rtype: list[StandardReturn]\n    \"\"\"\n    statement: Final[Statement] = Statement.ImportFrom\n    names: Final[list[str]] = [i.name for i in node.names]\n    path: Final[str | None] = node.module\n    category: ImportType = ImportType.Local\n    code: Final[str] = ast.unparse(node)\n    mod: str = f'{node.module}'\n    if bin(f'{mod}.'.split('.')[0], constants.BUILTIN_MODULES):\n        category = ImportType.Native\n    elif is_lib_installed(mod):\n        category = ImportType.TrdParty\n    for i in names:\n        data: StandardReturn = standard_struct()\n        data.update({'statement': statement, 'name': i, 'path': path, 'category': category, 'code': code})\n        struct.append(data)\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_attribute","title":"<code>def _handle_attribute</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Attribute</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Attribute</code> node and returns its code-like representation as str.</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing a slice expression.</p> <p>:type node: ast.Attribute</p> <p>:return: The readable code-like node build up.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_attribute(struct: list[StandardReturnProcessor], node: ast.Attribute) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Attribute` node and returns its code-like representation as str.\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing a slice expression.\n    :type node: ast.Attribute\n    :return: The readable code-like node build up.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_call","title":"<code>def _handle_call</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Call</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Call</code> node and returns its code-like representation as str.</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing a slice expression.</p> <p>:type node: ast.Call</p> <p>:return: The readable code-like node build up.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_call(struct: list[StandardReturnProcessor], node: ast.Call) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Call` node and returns its code-like representation as str.\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing a slice expression.\n    :type node: ast.Call\n    :return: The readable code-like node build up.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_constant","title":"<code>def _handle_constant</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Constant</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Constant</code> node and returns its code-like representation as str.</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing a slice expression.</p> <p>:type node: ast.Constant</p> <p>:return: The readable code-like node build up.</p> <p>:rtype: str</p> SNIPPET Python<pre><code>def _handle_constant(struct: list[StandardReturnProcessor], node: ast.Constant) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Constant` node and returns its code-like representation as str.\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing a slice expression.\n    :type node: ast.Constant\n    :return: The readable code-like node build up.\n    :rtype: str\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_assign","title":"<code>def _handle_assign</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturn]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturn], node: ast.Assign</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Assign</code> node and returns its data.</p> <p>This function analyzes the components of an assignment, including the target vars and the assigned value, returning a structured dict with the extracted details.</p> <p>Key elements of the returned data:</p> <ul> <li>tokens: A list of string repr for all target variables in the assignment.</li> <li>value: A string repr of the value being assigned.</li> </ul> <p>Example:</p> Python<pre><code>struct: dict = standard_struct()\nnode: ast.AST = ast.parse('num = 33').body[0]\nupdated_struct: dict = _handle_assign(struct, node)\nupdated_struct\n# Outputs standardized data for `num` definition.\n</code></pre> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturn]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.Assign</p> <p>:return: A dict containing the statement type, target variables, and assigned value.</p> <p>:rtype: list[StandardReturn]</p> SNIPPET Python<pre><code>def _handle_assign(struct: list[StandardReturn], node: ast.Assign) -&gt; list[StandardReturn]:\n    \"\"\"\n    Processes an `ast.Assign` node and returns its data.\n\n    This function analyzes the components of an assignment, including the target vars\n    and the assigned value, returning a structured dict with the extracted details.\n\n    Key elements of the returned data:\n    - tokens: A list of string repr for all target variables in the assignment.\n    - value: A string repr of the value being assigned.\n\n    Example:\n    ```python\n    struct: dict = standard_struct()\n    node: ast.AST = ast.parse('num = 33').body[0]\n    updated_struct: dict = _handle_assign(struct, node)\n    updated_struct\n    # Outputs standardized data for `num` definition.\n    ```\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturn]\n    :param node: The AST node representing the node statement.\n    :type node: ast.Assign\n    :return: A dict containing the statement type, target variables, and assigned value.\n    :rtype: list[StandardReturn]\n    \"\"\"\n    statement: Final[Statement] = Statement.Assign\n    tokens: Final[list[str]] = [cast(list[str], _handle_node(i))[0] for i in node.targets]\n    value: Final[str] = cast(list[str], _handle_node(node.value))[0]\n    code: Final[str] = ast.unparse(node)\n    data: StandardReturn = standard_struct()\n    data.update({'statement': statement, 'tokens': tokens, 'value': value, 'code': code})\n    struct.append(data)\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_binop","title":"<code>def _handle_binop</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.BinOp</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.BinOp</code> node and returns its code-like representation as str.</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing a binary operation expression.</p> <p>:type node: ast.BinOp</p> <p>:return: The readable code-like node build up.</p> <p>:rtype: str</p> SNIPPET Python<pre><code>def _handle_binop(struct: list[StandardReturnProcessor], node: ast.BinOp) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.BinOp` node and returns its code-like representation as str.\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing a binary operation expression.\n    :type node: ast.BinOp\n    :return: The readable code-like node build up.\n    :rtype: str\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_annassign","title":"<code>def _handle_annassign</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturn]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturn], node: ast.AnnAssign</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.AnnAssign</code> node and returns its data.</p> <p>This function analyzes the components of an assignment, including the target var and the assigned value, plus the typing notation, returning a structured dict with the extracted details.</p> <p>Key elements of the returned data:</p> <ul> <li>token: A string repr for the target var in the assignment.</li> <li>value: A string repr of the value being assigned.</li> <li>annot: The type hint for the assignment.</li> </ul> <p>Example:</p> Python<pre><code>struct: dict = standard_struct()\nnode: ast.AST = ast.parse('num: int = 33').body[0]\nupdated_struct: dict = _handle_anassign(struct, node)\nupdated_struct\n# Outputs standardized data for `num` definition with `int` annotation.\n</code></pre> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturn]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.AnnAssign</p> <p>:return: A dict with the statement type, target var, type hint and assigned value.</p> <p>:rtype: list[StandardReturn]</p> SNIPPET Python<pre><code>def _handle_annassign(struct: list[StandardReturn], node: ast.AnnAssign) -&gt; list[StandardReturn]:\n    \"\"\"\n    Processes an `ast.AnnAssign` node and returns its data.\n\n    This function analyzes the components of an assignment, including the target var\n    and the assigned value, plus the typing notation, returning a structured dict with\n    the extracted details.\n\n    Key elements of the returned data:\n    - token: A string repr for the target var in the assignment.\n    - value: A string repr of the value being assigned.\n    - annot: The type hint for the assignment.\n\n    Example:\n    ```python\n    struct: dict = standard_struct()\n    node: ast.AST = ast.parse('num: int = 33').body[0]\n    updated_struct: dict = _handle_anassign(struct, node)\n    updated_struct\n    # Outputs standardized data for `num` definition with `int` annotation.\n    ```\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturn]\n    :param node: The AST node representing the node statement.\n    :type node: ast.AnnAssign\n    :return: A dict with the statement type, target var, type hint and assigned value.\n    :rtype: list[StandardReturn]\n    \"\"\"\n    statement: Statement = Statement.AnnAssign\n    name: str = cast(list[str], _handle_node(node.target))[0]\n    annot: str = cast(list[str], _handle_node(node.annotation))[0]\n    value: str = ''\n    code: str = ast.unparse(node)\n    if node.value is not None:\n        value = cast(list[str], _handle_node(node.value))[0]\n    data: StandardReturn = standard_struct()\n    data.update({'statement': statement, 'name': name, 'annot': annot, 'value': value, 'code': code})\n    struct.append(data)\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-__format_arg","title":"<code>def __format_arg</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>str</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>name: str, annotation: str | None, default: str | None</code></p> <p>Kwargs: <code>None</code></p> <p>Formats a function argument into a string repr with optional type annotations and default values.</p> <p>This function constructs a f-string representing a function argument, including its name, optional type annotation, and default value. It ensures consistent formatting for use in function signatures or documentation.</p> <p>Key concepts:</p> <ul> <li>Type Annotations: Adds type annotations if provided.</li> <li>Default Values: Appends default values where applicable.</li> <li>Fallback Handling: If neither an annotation nor a default value is present, it   defaults to 'Unknown'.</li> </ul> <p>Example:</p> Python<pre><code>formatted: str = __format_arg('param', 'int', '42')\nformatted\n# \"param: int = 42\"\n</code></pre> <p>:param name: The name of the argument.</p> <p>:type name: str</p> <p>:param annotation: The type annotation for the argument, if any.</p> <p>:type annotation: str | None</p> <p>:param default: The default value of the argument, if any.</p> <p>:type default: str | None</p> <p>:return: A formatted string representing the argument.</p> <p>:rtype: str</p> SNIPPET Python<pre><code>def __format_arg(name: str, annotation: str | None, default: str | None) -&gt; str:\n    \"\"\"\n    Formats a function argument into a string repr with optional type annotations and\n    default values.\n\n    This function constructs a f-string representing a function argument, including its\n    name, optional type annotation, and default value. It ensures consistent formatting\n    for use in function signatures or documentation.\n\n    Key concepts:\n    - Type Annotations: Adds type annotations if provided.\n    - Default Values: Appends default values where applicable.\n    - Fallback Handling: If neither an annotation nor a default value is present, it\n      defaults to 'Unknown'.\n\n    Example:\n    ```python\n    formatted: str = __format_arg('param', 'int', '42')\n    formatted\n    # \"param: int = 42\"\n    ```\n\n    :param name: The name of the argument.\n    :type name: str\n    :param annotation: The type annotation for the argument, if any.\n    :type annotation: str | None\n    :param default: The default value of the argument, if any.\n    :type default: str | None\n    :return: A formatted string representing the argument.\n    :rtype: str\n    \"\"\"\n    if annotation and default:\n        return f'{name}: {annotation} = {default}'\n    elif annotation:\n        return f'{name}: {annotation}'\n    elif default:\n        return f'{name} = {default}'\n    else:\n        return f'{name}: Unknown'\n</code></pre>"},{"location":"mosheh/handler.py/#def-__process_function_args","title":"<code>def __process_function_args</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>str</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>node_args: ast.arguments</code></p> <p>Kwargs: <code>None</code></p> <p>Processes and formats positional arguments from a function definition.</p> <p>This function extracts positional arguments from an <code>ast.arguments</code> node, including their names, optional type annotations, and default values. It formats them into a single, comma-separated string repr suitable for documentation or code generation.</p> <p>Key concepts:</p> <ul> <li>Positional Arguments: Handles arguments that can be passed by position.</li> <li>Type Annotations: Extracts and formats type annotations, if present.</li> <li>Default Values: Aligns each argument with its default value, if provided.</li> </ul> <p>Example:</p> Python<pre><code>import ast\n\nsource: str = \"def example(a: int, b: str = 'default'): pass\"\nnode: ast.AST = ast.parse(source).body[0]\nformatted: str = __process_function_args(node.args)\nformatted\n# \"a: int, b: str = 'default'\"\n</code></pre> <p>:param node_args: The <code>arguments</code> node from an AST function definition.</p> <p>:type node_args: ast.arguments</p> <p>:return: A comma-separated string of formatted positional arguments.</p> <p>:rtype: str</p> SNIPPET Python<pre><code>def __process_function_args(node_args: ast.arguments) -&gt; str:\n    \"\"\"\n    Processes and formats positional arguments from a function definition.\n\n    This function extracts positional arguments from an `ast.arguments` node,\n    including their names, optional type annotations, and default values.\n    It formats them into a single, comma-separated string repr suitable\n    for documentation or code generation.\n\n    Key concepts:\n    - Positional Arguments: Handles arguments that can be passed by position.\n    - Type Annotations: Extracts and formats type annotations, if present.\n    - Default Values: Aligns each argument with its default value, if provided.\n\n    Example:\n    ```python\n    import ast\n\n    source: str = \"def example(a: int, b: str = 'default'): pass\"\n    node: ast.AST = ast.parse(source).body[0]\n    formatted: str = __process_function_args(node.args)\n    formatted\n    # \"a: int, b: str = 'default'\"\n    ```\n\n    :param node_args: The `arguments` node from an AST function definition.\n    :type node_args: ast.arguments\n    :return: A comma-separated string of formatted positional arguments.\n    :rtype: str\n    \"\"\"\n    formatted_args: list[str] = []\n    for i, arg in enumerate(node_args.args):\n        name: str = arg.arg\n        annotation: str | None = cast(list[str], _handle_node(arg.annotation))[0] if arg.annotation else None\n        default = None\n        if i &lt; len(node_args.kw_defaults):\n            default_node = node_args.kw_defaults[i]\n            if default_node:\n                default = str(cast(list[str], _handle_node(default_node))[0])\n        formatted_args.append(__format_arg(name, annotation, default))\n    return ', '.join(formatted_args)\n</code></pre>"},{"location":"mosheh/handler.py/#def-__process_function_kwargs","title":"<code>def __process_function_kwargs</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>str</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>node_args: ast.arguments</code></p> <p>Kwargs: <code>None</code></p> <p>Processes and formats keyword-only arguments from a function definition.</p> <p>This function extracts keyword-only arguments from an <code>ast.arguments</code> node, including their names, optional type annotations, and default values. It formats them into a single, comma-separated string repr suitable for documentation or code generation.</p> <p>Key concepts:</p> <ul> <li>Keyword-only Arguments: Processes arguments that must be passed by keyword.</li> <li>Type Annotations: Extracts and formats type annotations if present.</li> <li>Default Values: Handles default values, aligning them with their own arguments.</li> </ul> <p>Example:</p> Python<pre><code>import ast\n\nsource: str = 'def example(*, debug: bool = True): pass'\nnode: ast.AST = ast.parse(source).body[0]\nformatted: str = __process_function_kwargs(node.args)\nformatted\n# \"debug: bool = True\"\n</code></pre> <p>:param node_args: The <code>arguments</code> node from an AST function definition.</p> <p>:type node_args: ast.arguments</p> <p>:return: A comma-separated string of formatted keyword-only arguments.</p> <p>:rtype: str</p> SNIPPET Python<pre><code>def __process_function_kwargs(node_args: ast.arguments) -&gt; str:\n    \"\"\"\n    Processes and formats keyword-only arguments from a function definition.\n\n    This function extracts keyword-only arguments from an `ast.arguments` node,\n    including their names, optional type annotations, and default values. It formats\n    them into a single, comma-separated string repr suitable for documentation\n    or code generation.\n\n    Key concepts:\n    - Keyword-only Arguments: Processes arguments that must be passed by keyword.\n    - Type Annotations: Extracts and formats type annotations if present.\n    - Default Values: Handles default values, aligning them with their own arguments.\n\n    Example:\n    ```python\n    import ast\n\n    source: str = 'def example(*, debug: bool = True): pass'\n    node: ast.AST = ast.parse(source).body[0]\n    formatted: str = __process_function_kwargs(node.args)\n    formatted\n    # \"debug: bool = True\"\n    ```\n\n    :param node_args: The `arguments` node from an AST function definition.\n    :type node_args: ast.arguments\n    :return: A comma-separated string of formatted keyword-only arguments.\n    :rtype: str\n    \"\"\"\n    formatted_kwargs: list[str] = []\n    for i, arg in enumerate(node_args.kwonlyargs):\n        name: str = arg.arg\n        annotation: str | None = cast(list[str], _handle_node(arg.annotation))[0] if arg.annotation else None\n        default = None\n        if i &lt; len(node_args.kw_defaults):\n            default_node = node_args.kw_defaults[i]\n            if default_node:\n                default = str(cast(list[str], _handle_node(default_node))[0])\n        formatted_kwargs.append(__format_arg(name, annotation, default))\n    return ', '.join(formatted_kwargs)\n</code></pre>"},{"location":"mosheh/handler.py/#def-__process_function_type","title":"<code>def __process_function_type</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>FunctionType</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>node: ast.FunctionDef, is_from_class: bool</code></p> <p>Kwargs: <code>None</code></p> <p>Determines the type of a function based on its context and structure.</p> <p>This function identifies whether a given function node from the AST is a method, a generator, or a regular function.</p> <ul> <li>If is within a class or matches a dunder method name, it returns a <code>Method</code>.</li> <li>Elif contains a <code>yield</code> type statements, it returns a <code>Generator</code>.</li> <li>Otherwise, it returns a <code>Function</code>.</li> </ul> <p>:param node: The AST node representing the function.</p> <p>:type node: ast.FunctionDef</p> <p>:param is_from_class: Indicates if the function is defined within a class.</p> <p>:type is_from_class: bool</p> <p>:return: The type of the function (<code>Method</code>, <code>Generator</code>, or <code>Function</code>).</p> <p>:rtype: FunctionType</p> SNIPPET Python<pre><code>def __process_function_type(node: ast.FunctionDef, is_from_class: bool) -&gt; FunctionType:\n    \"\"\"\n    Determines the type of a function based on its context and structure.\n\n    This function identifies whether a given function node from the AST is a method,\n    a generator, or a regular function.\n\n    - If is within a class or matches a dunder method name, it returns a `Method`.\n    - Elif contains a `yield` type statements, it returns a `Generator`.\n    - Otherwise, it returns a `Function`.\n\n    :param node: The AST node representing the function.\n    :type node: ast.FunctionDef\n    :param is_from_class: Indicates if the function is defined within a class.\n    :type is_from_class: bool\n    :return: The type of the function (`Method`, `Generator`, or `Function`).\n    :rtype: FunctionType\n    \"\"\"\n    if is_from_class or bin(node.name, constants.BUILTIN_DUNDER_METHODS):\n        return FunctionType.Method\n    elif any((isinstance(n, ast.Yield | ast.YieldFrom) for n in ast.walk(node))):\n        return FunctionType.Generator\n    return FunctionType.Function\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_function_def","title":"<code>def _handle_function_def</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturn]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturn], node: ast.FunctionDef, is_from_class: bool</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.FunctionDef</code> node and returns its data.</p> <p>This function analyzes the components of a func def, mapping the name, decorators, arguments (name, type, default value), return type and even the type of function it is:</p> <ul> <li>Function: a base function, simply defined using <code>def</code> keyword.</li> <li>Method: also base function, but defined inside a class (e.g. <code>def __init__():</code>).</li> <li>Generator: process an iterable object at a time, on demand, with <code>yield</code> inside.</li> </ul> <p>Example:</p> Python<pre><code>from typing import Any\n\nstruct: dict = standard_struct()\nnode: ast.AST = ast.parse('def foo(*args: Any):\npass').body[0]\nupdated_struct: dict = _handle_function_def(struct, node)\nupdated_struct\n# Outputs standardized data for `foo` definition.\n</code></pre> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturn]</p> <p>:param node: The AST node representing a func def statement.</p> <p>:type node: ast.FunctionDef</p> <p>:param is_from_class: The arg who tells if shoud be directly defined as a Method.</p> <p>:type is_from_class: bool</p> <p>:return: A dict containing the statement type and the data listed before.</p> <p>:rtype: list[StandardReturn]</p> SNIPPET Python<pre><code>def _handle_function_def(struct: list[StandardReturn], node: ast.FunctionDef, is_from_class: bool=False) -&gt; list[StandardReturn]:\n    \"\"\"\n    Processes an `ast.FunctionDef` node and returns its data.\n\n    This function analyzes the components of a func def, mapping the name, decorators,\n    arguments (name, type, default value), return type and even the type of function it\n    is:\n    - Function: a base function, simply defined using `def` keyword.\n    - Method: also base function, but defined inside a class (e.g. `def __init__():`).\n    - Generator: process an iterable object at a time, on demand, with `yield` inside.\n\n    Example:\n    ```python\n    from typing import Any\n\n    struct: dict = standard_struct()\n    node: ast.AST = ast.parse('def foo(*args: Any):\n    pass').body[0]\n    updated_struct: dict = _handle_function_def(struct, node)\n    updated_struct\n    # Outputs standardized data for `foo` definition.\n    ```\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturn]\n    :param node: The AST node representing a func def statement.\n    :type node: ast.FunctionDef\n    :param is_from_class: The arg who tells if shoud be directly defined as a Method.\n    :type is_from_class: bool\n    :return: A dict containing the statement type and the data listed before.\n    :rtype: list[StandardReturn]\n    \"\"\"\n    statement: Final[Statement] = Statement.FunctionDef\n    name: Final[str] = node.name\n    docstring: Final[str | None] = ast.get_docstring(node)\n    decos: Final[list[str]] = [cast(list[str], _handle_node(i))[0] for i in node.decorator_list]\n    rtype: Final[str] | None = cast(list[str], _handle_node(node.returns))[0] if node.returns is not None else None\n    code: Final[str] = ast.unparse(node)\n    args_str: str = __process_function_args(node.args)\n    kwargs_str: str = __process_function_kwargs(node.args)\n    category: FunctionType = __process_function_type(node, is_from_class)\n    data: StandardReturn = standard_struct()\n    data.update({'statement': statement, 'name': name, 'category': category, 'docstring': docstring, 'decorators': decos, 'rtype': rtype, 'args': args_str, 'kwargs': kwargs_str, 'code': code})\n    struct.append(data)\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_async_function_def","title":"<code>def _handle_async_function_def</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturn]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturn], node: ast.AsyncFunctionDef</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.AsyncFunctionDef</code> node and returns its data.</p> <p>This function analyzes the components of a func def, mapping the name, decorators, arguments (name, type, default value), return type and even the type of function it is, which in this case can be only one:</p> <ul> <li>Coroutine: An async func, defined with <code>async def</code> syntax...</li> </ul> <p>Example:</p> Python<pre><code>from typing import Any\n\nstruct: dict = standard_struct()\nnode: ast.AST = ast.parse('async def foo(*args: Any):\npass').body[0]\nupdated_struct: dict = _handle_assign(struct, node)\nupdated_struct\n# Outputs standardized data for async `foo` definition.\n</code></pre> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturn]</p> <p>:param node: The AST node representing a func def statement.</p> <p>:type node: ast.AsyncFunctionDef</p> <p>:return: A dict containing the statement type and the data listed before.</p> <p>:rtype: list[StandardReturn]</p> SNIPPET Python<pre><code>def _handle_async_function_def(struct: list[StandardReturn], node: ast.AsyncFunctionDef) -&gt; list[StandardReturn]:\n    \"\"\"\n    Processes an `ast.AsyncFunctionDef` node and returns its data.\n\n    This function analyzes the components of a func def, mapping the name, decorators,\n    arguments (name, type, default value), return type and even the type of function it\n    is, which in this case can be only one:\n    - Coroutine: An async func, defined with `async def` syntax...\n\n    Example:\n    ```python\n    from typing import Any\n\n    struct: dict = standard_struct()\n    node: ast.AST = ast.parse('async def foo(*args: Any):\n    pass').body[0]\n    updated_struct: dict = _handle_assign(struct, node)\n    updated_struct\n    # Outputs standardized data for async `foo` definition.\n    ```\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturn]\n    :param node: The AST node representing a func def statement.\n    :type node: ast.AsyncFunctionDef\n    :return: A dict containing the statement type and the data listed before.\n    :rtype: list[StandardReturn]\n    \"\"\"\n    statement: Final[Statement] = Statement.AsyncFunctionDef\n    name: Final[str] = node.name\n    docstring: Final[str | None] = ast.get_docstring(node)\n    decos: Final[list[str]] = [cast(list[str], _handle_node(i))[0] for i in node.decorator_list]\n    rtype: Final[str] | None = cast(list[str], _handle_node(node.returns))[0] if node.returns is not None else None\n    code: Final[str] = ast.unparse(node)\n    args_str: str = __process_function_args(node.args)\n    kwargs_str: str = __process_function_kwargs(node.args)\n    data: StandardReturn = standard_struct()\n    data.update({'statement': statement, 'name': name, 'category': FunctionType.Coroutine, 'docstring': docstring, 'decorators': decos, 'rtype': rtype, 'args': args_str, 'kwargs': kwargs_str, 'code': code})\n    struct.append(data)\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-__format_class_kwarg","title":"<code>def __format_class_kwarg</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>str</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>name: str | None, value: ast.expr</code></p> <p>Kwargs: <code>None</code></p> <p>Formats a kwarg from a class definition into a string repr.</p> <p>This function converts an AST kwarg into a string, representing it in the format <code>name=value</code>. If the keyword has no name (e.g., for positional arguments), only the value is returned.</p> <p>Key concepts:</p> <ul> <li>AST Unparsing: Uses <code>ast.unparse</code> to convert an AST expression into its   corresponding Python code as a string.</li> <li>Conditional Formatting: Handles named and unnamed (positional) keyword arguments.</li> </ul> <p>Example:</p> Python<pre><code>import ast\n\nkwarg: ast.keyword = ast.keyword(arg='debug', value=ast.Constant(value=True))\nformatted: str = __format_class_kwarg(kwarg.arg, kwarg.value)\nformatted\n# \"debug = True\"\n</code></pre> <p>:param name: The name of the kwarg (can be <code>None</code> for positional arguments).</p> <p>:type name: str | None</p> <p>:param value: The AST expression representing the value of the keyword argument.</p> <p>:type value: ast.expr</p> <p>:return: A formatted string representing the keyword argument.</p> <p>:rtype: str</p> SNIPPET Python<pre><code>def __format_class_kwarg(name: str | None, value: ast.expr) -&gt; str:\n    \"\"\"\n    Formats a kwarg from a class definition into a string repr.\n\n    This function converts an AST kwarg into a string, representing it in the format\n    `name=value`. If the keyword has no name (e.g., for positional arguments), only the\n    value is returned.\n\n    Key concepts:\n    - AST Unparsing: Uses `ast.unparse` to convert an AST expression into its\n      corresponding Python code as a string.\n    - Conditional Formatting: Handles named and unnamed (positional) keyword arguments.\n\n    Example:\n    ```python\n    import ast\n\n    kwarg: ast.keyword = ast.keyword(arg='debug', value=ast.Constant(value=True))\n    formatted: str = __format_class_kwarg(kwarg.arg, kwarg.value)\n    formatted\n    # \"debug = True\"\n    ```\n\n    :param name: The name of the kwarg (can be `None` for positional arguments).\n    :type name: str | None\n    :param value: The AST expression representing the value of the keyword argument.\n    :type value: ast.expr\n    :return: A formatted string representing the keyword argument.\n    :rtype: str\n    \"\"\"\n    value_str: str = ast.unparse(value)\n    if name:\n        return f'{name} = {value_str}'\n    return value_str\n</code></pre>"},{"location":"mosheh/handler.py/#def-__process_class_kwargs","title":"<code>def __process_class_kwargs</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>str</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>keywords: list[ast.keyword]</code></p> <p>Kwargs: <code>None</code></p> <p>Processes and formats keyword arguments from a class definition.</p> <p>This function takes a list of keyword arguments (from an AST node) and formats them into a single, comma-separated string. Each keyword is processed using the <code>__format_class_kwarg</code> function to ensure consistent repr.</p> <p>Key concepts:</p> <ul> <li>Keyword Formatting: Converts each kwarg into a string repr   of the form <code>key=value</code>.</li> <li>List Processing: Aggregates and joins all formatted keyword arguments into a   single string for use in documentation or code generation.</li> </ul> <p>Example:</p> Python<pre><code>keywords: list[ast.keydwor] = [\n    ast.keyword(arg='name', value=ast.Constant(value='MyClass'))\n]\nformatted: str = __process_class_kwargs(keywords)\nformatted\n# \"name='MyClass'\"\n</code></pre> <p>:param keywords: A list of AST keyword arguments.</p> <p>:type keywords: list[ast.keyword]</p> <p>:return: A comma-separated string of formatted keyword arguments.</p> <p>:rtype: str</p> SNIPPET Python<pre><code>def __process_class_kwargs(keywords: list[ast.keyword]) -&gt; str:\n    \"\"\"\n    Processes and formats keyword arguments from a class definition.\n\n    This function takes a list of keyword arguments (from an AST node) and formats\n    them into a single, comma-separated string. Each keyword is processed using\n    the `__format_class_kwarg` function to ensure consistent repr.\n\n    Key concepts:\n    - Keyword Formatting: Converts each kwarg into a string repr\n      of the form `key=value`.\n    - List Processing: Aggregates and joins all formatted keyword arguments into a\n      single string for use in documentation or code generation.\n\n    Example:\n    ```python\n    keywords: list[ast.keydwor] = [\n        ast.keyword(arg='name', value=ast.Constant(value='MyClass'))\n    ]\n    formatted: str = __process_class_kwargs(keywords)\n    formatted\n    # \"name='MyClass'\"\n    ```\n\n    :param keywords: A list of AST keyword arguments.\n    :type keywords: list[ast.keyword]\n    :return: A comma-separated string of formatted keyword arguments.\n    :rtype: str\n    \"\"\"\n    formatted_kwargs: list[str] = [__format_class_kwarg(kw.arg, kw.value) for kw in keywords]\n    return ', '.join(formatted_kwargs)\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_class_def","title":"<code>def _handle_class_def</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturn]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturn], node: ast.ClassDef</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.ClassDef</code> node and returns its data.</p> <p>This function analyzes the components of a class definition, including its name, base classes, decorators, and keyword arguments, returning a structured dict with the extracted details.</p> <p>Key elements of the returned data:</p> <ul> <li>name: The name of the class as a string.</li> <li>parents: A list of string reprs for the base classes of the class.</li> <li>decos: A list of string reprs for all decorators applied to the class.</li> <li>kwargs: A list of tuples, in <code>(name, value)</code> style.</li> </ul> <p>Example:</p> Python<pre><code>struct: dict = standard_struct()\nnode: ast.AST = ast.parse('class Foo:\npass').body[0]\nupdated_struct: dict = _handle_class_def(struct, node)\nupdated_struct\n# Outputs standardized data for `Foo` definition.\n</code></pre> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturn]</p> <p>:param node: The AST node representing a class definition.</p> <p>:type node: ast.ClassDef</p> <p>:return: A dict with the statement type, name, base classes, decorators, and kwargs.</p> <p>:rtype: list[StandardReturn]</p> SNIPPET Python<pre><code>def _handle_class_def(struct: list[StandardReturn], node: ast.ClassDef) -&gt; list[StandardReturn]:\n    \"\"\"\n    Processes an `ast.ClassDef` node and returns its data.\n\n    This function analyzes the components of a class definition, including its name,\n    base classes, decorators, and keyword arguments, returning a structured dict with\n    the extracted details.\n\n    Key elements of the returned data:\n    - name: The name of the class as a string.\n    - parents: A list of string reprs for the base classes of the class.\n    - decos: A list of string reprs for all decorators applied to the class.\n    - kwargs: A list of tuples, in `(name, value)` style.\n\n    Example:\n    ```python\n    struct: dict = standard_struct()\n    node: ast.AST = ast.parse('class Foo:\n    pass').body[0]\n    updated_struct: dict = _handle_class_def(struct, node)\n    updated_struct\n    # Outputs standardized data for `Foo` definition.\n    ```\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturn]\n    :param node: The AST node representing a class definition.\n    :type node: ast.ClassDef\n    :return: A dict with the statement type, name, base classes, decorators, and kwargs.\n    :rtype: list[StandardReturn]\n    \"\"\"\n    statement: Final[Statement] = Statement.ClassDef\n    name: Final[str] = node.name\n    docstring: Final[str | None] = ast.get_docstring(node)\n    inheritance: Final[list[str]] = [cast(list[str], _handle_node(i))[0] for i in node.bases if isinstance(i, ast.Name)]\n    decos: Final[list[str]] = [cast(list[str], _handle_node(i))[0] for i in node.decorator_list]\n    kwargs_str: str = __process_class_kwargs(node.keywords)\n    code: Final[str] = ast.unparse(node)\n    data: StandardReturn = standard_struct()\n    data.update({'statement': statement, 'name': name, 'docstring': docstring, 'inheritance': inheritance, 'decorators': decos, 'kwargs': kwargs_str, 'code': code})\n    struct.append(data)\n    for child in node.body:\n        if isinstance(child, ast.FunctionDef):\n            data: StandardReturn = standard_struct()\n            data.update(_handle_function_def([], child, is_from_class=True)[0])\n            struct.append(data)\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_compare","title":"<code>def _handle_compare</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Compare</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Compare</code> node and returns its code-like representation as str.</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing a compare expression.</p> <p>:type node: ast.Compare</p> <p>:return: The readable code-like node build up.</p> <p>:rtype: str</p> SNIPPET Python<pre><code>def _handle_compare(struct: list[StandardReturnProcessor], node: ast.Compare) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Compare` node and returns its code-like representation as str.\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing a compare expression.\n    :type node: ast.Compare\n    :return: The readable code-like node build up.\n    :rtype: str\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_unary","title":"<code>def _handle_unary</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.UnaryOp</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.UnaryOp</code> node and returns its code-like representation as str.</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing a compare expression.</p> <p>:type node: ast.UnaryOp</p> <p>:return: The readable code-like node build up.</p> <p>:rtype: str</p> SNIPPET Python<pre><code>def _handle_unary(struct: list[StandardReturnProcessor], node: ast.UnaryOp) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.UnaryOp` node and returns its code-like representation as str.\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing a compare expression.\n    :type node: ast.UnaryOp\n    :return: The readable code-like node build up.\n    :rtype: str\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_assert","title":"<code>def _handle_assert</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturn]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturn], node: ast.Assert</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Assert</code> node and returns its data.</p> <p>This function analyzes the components of an assertion, including the expression of the test and the optional message, returning a structured dict with the extracted details.</p> <p>Key elements of the returned data:</p> <ul> <li>statement: The type of statement, identified as <code>Statement.Assert</code>.</li> <li>test: A repr of the test expression being asserted.</li> <li>msg: A string repr of the optional message, <code>None</code> if no message is provided.</li> </ul> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturn]</p> <p>:param node: The AST node representing an assertion statement.</p> <p>:type node: ast.Assert</p> <p>:return: A dict with the statement type, test expression, and optional message.</p> <p>:rtype: list[StandardReturn]</p> SNIPPET Python<pre><code>def _handle_assert(struct: list[StandardReturn], node: ast.Assert) -&gt; list[StandardReturn]:\n    \"\"\"\n    Processes an `ast.Assert` node and returns its data.\n\n    This function analyzes the components of an assertion, including the expression of\n    the test and the optional message, returning a structured dict with the extracted\n    details.\n\n    Key elements of the returned data:\n    - statement: The type of statement, identified as `Statement.Assert`.\n    - test: A repr of the test expression being asserted.\n    - msg: A string repr of the optional message, `None` if no message is provided.\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturn]\n    :param node: The AST node representing an assertion statement.\n    :type node: ast.Assert\n    :return: A dict with the statement type, test expression, and optional message.\n    :rtype: list[StandardReturn]\n    \"\"\"\n    statement: Final[Statement] = Statement.Assert\n    test: str = cast(list[str], _handle_node(node.test))[0]\n    msg: Final[str | None] = cast(list[str], _handle_node(node.msg))[0] if node.msg else None\n    code: Final[str] = ast.unparse(node)\n    data: StandardReturn = standard_struct()\n    data.update({'statement': statement, 'test': test, 'msg': msg, 'code': code})\n    struct.append(data)\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_list","title":"<code>def _handle_list</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.List</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.List</code> node and returns its code-like representation as str.</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing a list expression.</p> <p>:type node: ast.List</p> <p>:return: The readable code-like node build up.</p> <p>:rtype: str</p> SNIPPET Python<pre><code>def _handle_list(struct: list[StandardReturnProcessor], node: ast.List) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.List` node and returns its code-like representation as str.\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing a list expression.\n    :type node: ast.List\n    :return: The readable code-like node build up.\n    :rtype: str\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_tuple","title":"<code>def _handle_tuple</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Tuple</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Tuple</code> node and returns its code-like representation as str.</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing a tuple expression.</p> <p>:type node: ast.Tuple</p> <p>:return: The readable code-like node build up.</p> <p>:rtype: str</p> SNIPPET Python<pre><code>def _handle_tuple(struct: list[StandardReturnProcessor], node: ast.Tuple) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Tuple` node and returns its code-like representation as str.\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing a tuple expression.\n    :type node: ast.Tuple\n    :return: The readable code-like node build up.\n    :rtype: str\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_set","title":"<code>def _handle_set</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Set</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Set</code> node and returns its code-like representation as str.</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing a set expression.</p> <p>:type node: ast.Set</p> <p>:return: The readable code-like node build up.</p> <p>:rtype: str</p> SNIPPET Python<pre><code>def _handle_set(struct: list[StandardReturnProcessor], node: ast.Set) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Set` node and returns its code-like representation as str.\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing a set expression.\n    :type node: ast.Set\n    :return: The readable code-like node build up.\n    :rtype: str\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_dict","title":"<code>def _handle_dict</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Dict</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Dict</code> node and returns its code-like representation as str.</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing a dict expression.</p> <p>:type node: ast.Dict</p> <p>:return: The readable code-like node build up.</p> <p>:rtype: str</p> SNIPPET Python<pre><code>def _handle_dict(struct: list[StandardReturnProcessor], node: ast.Dict) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Dict` node and returns its code-like representation as str.\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing a dict expression.\n    :type node: ast.Dict\n    :return: The readable code-like node build up.\n    :rtype: str\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_subscript","title":"<code>def _handle_subscript</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Subscript</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Subscript</code> node and returns its code-like representation as str.</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing a subscript expression.</p> <p>:type node: ast.Subscript</p> <p>:return: The readable code-like node build up.</p> <p>:rtype: str</p> SNIPPET Python<pre><code>def _handle_subscript(struct: list[StandardReturnProcessor], node: ast.Subscript) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Subscript` node and returns its code-like representation as str.\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing a subscript expression.\n    :type node: ast.Subscript\n    :return: The readable code-like node build up.\n    :rtype: str\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_slice","title":"<code>def _handle_slice</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Slice</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Slice</code> node and returns its code-like representation as str.</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing a slice expression.</p> <p>:type node: ast.Slice</p> <p>:return: The readable code-like node build up.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_slice(struct: list[StandardReturnProcessor], node: ast.Slice) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Slice` node and returns its code-like representation as str.\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing a slice expression.\n    :type node: ast.Slice\n    :return: The readable code-like node build up.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_name","title":"<code>def _handle_name</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Name</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Name</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.Name</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_name(struct: list[StandardReturnProcessor], node: ast.Name) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Name` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.Name\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_joined_str","title":"<code>def _handle_joined_str</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.JoinedStr</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.JoinedStr</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.JoinedStr</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_joined_str(struct: list[StandardReturnProcessor], node: ast.JoinedStr) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.JoinedStr` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.JoinedStr\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_if_expression","title":"<code>def _handle_if_expression</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.IfExp</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.IfExp</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.IfExp</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_if_expression(struct: list[StandardReturnProcessor], node: ast.IfExp) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.IfExp` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.IfExp\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_bool_op","title":"<code>def _handle_bool_op</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.BoolOp</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.BoolOp</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.BoolOp</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_bool_op(struct: list[StandardReturnProcessor], node: ast.BoolOp) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.BoolOp` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.BoolOp\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_comprehensions","title":"<code>def _handle_comprehensions</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.ListComp | ast.DictComp | ast.SetComp | ast.GeneratorExp</code></p> <p>Kwargs: <code>None</code></p> <p>Processes a comprehension node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.ListComp | ast.DictComp | ast.SetComp | ast.GeneratorExp</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_comprehensions(struct: list[StandardReturnProcessor], node: ast.ListComp | ast.DictComp | ast.SetComp | ast.GeneratorExp) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes a comprehension node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.ListComp | ast.DictComp | ast.SetComp | ast.GeneratorExp\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_lambda","title":"<code>def _handle_lambda</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Lambda</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Lambda</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.Lambda</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_lambda(struct: list[StandardReturnProcessor], node: ast.Lambda) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Lambda` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.Lambda\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_formatted_value","title":"<code>def _handle_formatted_value</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.FormattedValue</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.FormattedValue</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.FormattedValue</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_formatted_value(struct: list[StandardReturnProcessor], node: ast.FormattedValue) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.FormattedValue` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.FormattedValue\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_load","title":"<code>def _handle_load</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Load</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Load</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.Load</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_load(struct: list[StandardReturnProcessor], node: ast.Load) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Load` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.Load\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_store","title":"<code>def _handle_store</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Store</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Store</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.Store</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_store(struct: list[StandardReturnProcessor], node: ast.Store) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Store` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.Store\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_del","title":"<code>def _handle_del</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Del</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Del</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.Del</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_del(struct: list[StandardReturnProcessor], node: ast.Del) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Del` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.Del\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_starred","title":"<code>def _handle_starred</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Starred</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Starred</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.Starred</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_starred(struct: list[StandardReturnProcessor], node: ast.Starred) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Starred` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.Starred\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_expr","title":"<code>def _handle_expr</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Expr</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Expr</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.Expr</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_expr(struct: list[StandardReturnProcessor], node: ast.Expr) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Expr` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.Expr\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_named_expr","title":"<code>def _handle_named_expr</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.NamedExpr</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.NamedExpr</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.NamedExpr</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_named_expr(struct: list[StandardReturnProcessor], node: ast.NamedExpr) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.NamedExpr` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.NamedExpr\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_augassign","title":"<code>def _handle_augassign</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.AugAssign</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.AugAssign</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.AugAssign</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_augassign(struct: list[StandardReturnProcessor], node: ast.AugAssign) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.AugAssign` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.AugAssign\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_raise","title":"<code>def _handle_raise</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Raise</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Raise</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.Raise</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_raise(struct: list[StandardReturnProcessor], node: ast.Raise) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Raise` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.Raise\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_delete","title":"<code>def _handle_delete</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Delete</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Delete</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.Delete</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_delete(struct: list[StandardReturnProcessor], node: ast.Delete) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Delete` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.Delete\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_pass","title":"<code>def _handle_pass</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Pass</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Pass</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.Pass</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_pass(struct: list[StandardReturnProcessor], node: ast.Pass) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Pass` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.Pass\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_type_alias","title":"<code>def _handle_type_alias</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.TypeAlias</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.TypeAlias</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.TypeAlias</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_type_alias(struct: list[StandardReturnProcessor], node: ast.TypeAlias) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.TypeAlias` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.TypeAlias\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_if","title":"<code>def _handle_if</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.If</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.If</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.If</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_if(struct: list[StandardReturnProcessor], node: ast.If) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.If` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.If\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_for","title":"<code>def _handle_for</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.For</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.For</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.For</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_for(struct: list[StandardReturnProcessor], node: ast.For) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.For` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.For\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_while","title":"<code>def _handle_while</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.While</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.While</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.While</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_while(struct: list[StandardReturnProcessor], node: ast.While) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.While` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.While\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_break","title":"<code>def _handle_break</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Break</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Break</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.Break</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_break(struct: list[StandardReturnProcessor], node: ast.Break) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Break` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.Break\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_continue","title":"<code>def _handle_continue</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Continue</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Continue</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.Continue</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_continue(struct: list[StandardReturnProcessor], node: ast.Continue) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Continue` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.Continue\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_try","title":"<code>def _handle_try</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Try</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Try</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.Try</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_try(struct: list[StandardReturnProcessor], node: ast.Try) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Try` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.Try\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_try_star","title":"<code>def _handle_try_star</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.TryStar</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.TryStar</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.TryStar</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_try_star(struct: list[StandardReturnProcessor], node: ast.TryStar) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.TryStar` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.TryStar\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_except_handler","title":"<code>def _handle_except_handler</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.ExceptHandler</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.ExceptHandler</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.ExceptHandler</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_except_handler(struct: list[StandardReturnProcessor], node: ast.ExceptHandler) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.ExceptHandler` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.ExceptHandler\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_with","title":"<code>def _handle_with</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.With</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.With</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.With</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_with(struct: list[StandardReturnProcessor], node: ast.With) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.With` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.With\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_match","title":"<code>def _handle_match</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Match</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Match</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.Match</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_match(struct: list[StandardReturnProcessor], node: ast.Match) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Match` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.Match\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_type_var","title":"<code>def _handle_type_var</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.TypeVar</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.TypeVar</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.TypeVar</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_type_var(struct: list[StandardReturnProcessor], node: ast.TypeVar) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.TypeVar` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.TypeVar\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_param_spec","title":"<code>def _handle_param_spec</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.ParamSpec</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.ParamSpec</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.ParamSpec</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_param_spec(struct: list[StandardReturnProcessor], node: ast.ParamSpec) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.ParamSpec` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.ParamSpec\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_type_var_tuple","title":"<code>def _handle_type_var_tuple</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.TypeVarTuple</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.TypeVarTuple</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.TypeVarTuple</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_type_var_tuple(struct: list[StandardReturnProcessor], node: ast.TypeVarTuple) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.TypeVarTuple` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.TypeVarTuple\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_return","title":"<code>def _handle_return</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Return</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Return</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.Return</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_return(struct: list[StandardReturnProcessor], node: ast.Return) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Return` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.Return\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_yield","title":"<code>def _handle_yield</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Yield</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Yield</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.Yield</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_yield(struct: list[StandardReturnProcessor], node: ast.Yield) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Yield` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.Yield\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_yield_from","title":"<code>def _handle_yield_from</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.YieldFrom</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.YieldFrom</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.YieldFrom</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_yield_from(struct: list[StandardReturnProcessor], node: ast.YieldFrom) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.YieldFrom` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.YieldFrom\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_global","title":"<code>def _handle_global</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Global</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Global</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.Global</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_global(struct: list[StandardReturnProcessor], node: ast.Global) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Global` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.Global\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_nonlocal","title":"<code>def _handle_nonlocal</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Nonlocal</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Nonlocal</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.Nonlocal</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_nonlocal(struct: list[StandardReturnProcessor], node: ast.Nonlocal) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Nonlocal` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.Nonlocal\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_await","title":"<code>def _handle_await</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.Await</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.Await</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.Await</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_await(struct: list[StandardReturnProcessor], node: ast.Await) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.Await` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.Await\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_async_for","title":"<code>def _handle_async_for</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.AsyncFor</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.AsyncFor</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.AsyncFor</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_async_for(struct: list[StandardReturnProcessor], node: ast.AsyncFor) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.AsyncFor` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.AsyncFor\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-_handle_async_with","title":"<code>def _handle_async_with</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>list[StandardReturnProcessor]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>struct: list[StandardReturnProcessor], node: ast.AsyncWith</code></p> <p>Kwargs: <code>None</code></p> <p>Processes an <code>ast.AsyncWith</code> node and returns its data.</p> <p>This function just returns the node id, as str...</p> <p>:param struct: The structure to be updated with statement details.</p> <p>:type struct: list[StandardReturnProcessor]</p> <p>:param node: The AST node representing the node statement.</p> <p>:type node: ast.AsyncWith</p> <p>:return: The node id.</p> <p>:rtype: list[StandardReturnProcessor]</p> SNIPPET Python<pre><code>def _handle_async_with(struct: list[StandardReturnProcessor], node: ast.AsyncWith) -&gt; list[StandardReturnProcessor]:\n    \"\"\"\n    Processes an `ast.AsyncWith` node and returns its data.\n\n    This function just returns the node id, as str...\n\n    :param struct: The structure to be updated with statement details.\n    :type struct: list[StandardReturnProcessor]\n    :param node: The AST node representing the node statement.\n    :type node: ast.AsyncWith\n    :return: The node id.\n    :rtype: list[StandardReturnProcessor]\n    \"\"\"\n    struct.append(ast.unparse(node))\n    return struct\n</code></pre>"},{"location":"mosheh/handler.py/#def-update_data","title":"<code>def update_data</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>Unknown</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>new_data: list[StandardReturn]</code></p> <p>Kwargs: <code>None</code></p> <p>No <code>docstring</code> provided.</p> SNIPPET Python<pre><code>def update_data(new_data: list[StandardReturn]):\n    nonlocal data\n    data = cast(list[StandardReturnProcessor], new_data)\n</code></pre>"},{"location":"mosheh/handler.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"mosheh/main.py/","title":"File: <code>main.py</code>","text":"<p>Role: Python Source Code</p> <p>Path: <code>mosheh</code></p> <p>Mosheh, a tool for creating docs for projects, from Python to Python.</p> <p>Basically, Mosheh lists all files you points to, saves every single notorious statement of definition on each file iterated, all using Python <code>ast</code> native module for handling the AST and then generating (using MkDocs) a documentation respecting the dirs and files hierarchy. The stuff documented for each file are listed below:</p> <ul> <li> <p>Imports <code>[ast.Import | ast.ImportFrom]</code></p> </li> <li> <p> Type <code>[Native | TrdParty | Local]</code></p> </li> <li> Path (e.g. 'django.http')</li> <li> <p> Code</p> </li> <li> <p>Constants <code>[ast.Assign | ast.AnnAssign]</code></p> </li> <li> <p> Name (token name)</p> </li> <li> Typing Notation (datatype)</li> <li> Value (literal or call)</li> <li> <p> Code</p> </li> <li> <p>Classes <code>[ast.ClassDef]</code></p> </li> <li> <p> Description (docstring)</p> </li> <li> Name (class name)</li> <li> Parents (inheritance)</li> <li> Methods Defined (nums and names)</li> <li> Example (usage)</li> <li> <p> Code</p> </li> <li> <p>Funcs <code>[ast.FunctionDef | ast.AsyncFunctionDef]</code></p> </li> <li> <p> Description (docstring)</p> </li> <li> Name (func name)</li> <li> Type <code>[Func | Method | Generator | Coroutine]</code></li> <li> Parameters (name, type, default)</li> <li> Return Type (datatype)</li> <li> Raises (exception throw)</li> <li> Example (usage)</li> <li> <p> Code</p> </li> <li> <p>Assertions <code>[ast.Assert]</code></p> </li> <li> <p> Test (assertion by itself)</p> </li> <li> Message (opt. message in fail case)</li> <li> Code</li> </ul>"},{"location":"mosheh/main.py/#imports","title":"Imports","text":""},{"location":"mosheh/main.py/#import","title":"<code>import *</code>","text":"<p>Path: <code>metadata</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from metadata import *\n</code></pre>"},{"location":"mosheh/main.py/#import-argumentparser","title":"<code>import ArgumentParser</code>","text":"<p>Path: <code>argparse</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from argparse import ArgumentParser\n</code></pre>"},{"location":"mosheh/main.py/#import-namespace","title":"<code>import Namespace</code>","text":"<p>Path: <code>argparse</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from argparse import Namespace\n</code></pre>"},{"location":"mosheh/main.py/#import-rawdescriptionhelpformatter","title":"<code>import RawDescriptionHelpFormatter</code>","text":"<p>Path: <code>argparse</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from argparse import RawDescriptionHelpFormatter\n</code></pre>"},{"location":"mosheh/main.py/#import-critical","title":"<code>import CRITICAL</code>","text":"<p>Path: <code>logging</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from logging import CRITICAL\n</code></pre>"},{"location":"mosheh/main.py/#import-debug","title":"<code>import DEBUG</code>","text":"<p>Path: <code>logging</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from logging import DEBUG\n</code></pre>"},{"location":"mosheh/main.py/#import-error","title":"<code>import ERROR</code>","text":"<p>Path: <code>logging</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from logging import ERROR\n</code></pre>"},{"location":"mosheh/main.py/#import-info","title":"<code>import INFO</code>","text":"<p>Path: <code>logging</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from logging import INFO\n</code></pre>"},{"location":"mosheh/main.py/#import-warning","title":"<code>import WARNING</code>","text":"<p>Path: <code>logging</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from logging import WARNING\n</code></pre>"},{"location":"mosheh/main.py/#import-basicconfig","title":"<code>import basicConfig</code>","text":"<p>Path: <code>logging</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from logging import basicConfig\n</code></pre>"},{"location":"mosheh/main.py/#import-getlogger","title":"<code>import getLogger</code>","text":"<p>Path: <code>logging</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from logging import getLogger\n</code></pre>"},{"location":"mosheh/main.py/#import-path","title":"<code>import path</code>","text":"<p>Path: <code>os</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from os import path\n</code></pre>"},{"location":"mosheh/main.py/#import-calledprocesserror","title":"<code>import CalledProcessError</code>","text":"<p>Path: <code>subprocess</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from subprocess import CalledProcessError\n</code></pre>"},{"location":"mosheh/main.py/#import-richhandler","title":"<code>import RichHandler</code>","text":"<p>Path: <code>rich.logging</code></p> <p>Category: 3rd Party</p> SNIPPET Python<pre><code>from rich.logging import RichHandler\n</code></pre>"},{"location":"mosheh/main.py/#import-read_codebase","title":"<code>import read_codebase</code>","text":"<p>Path: <code>codebase</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from codebase import read_codebase\n</code></pre>"},{"location":"mosheh/main.py/#import-codebasedict","title":"<code>import CodebaseDict</code>","text":"<p>Path: <code>custom_types</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from custom_types import CodebaseDict\n</code></pre>"},{"location":"mosheh/main.py/#import-generate_doc","title":"<code>import generate_doc</code>","text":"<p>Path: <code>doc</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from doc import generate_doc\n</code></pre>"},{"location":"mosheh/main.py/#consts","title":"Consts","text":""},{"location":"mosheh/main.py/#root","title":"<code>ROOT</code>","text":"<p>Type: <code>str</code></p> <p>Value: <code>args.root</code></p> SNIPPET Python<pre><code>ROOT: str = args.root\n</code></pre>"},{"location":"mosheh/main.py/#proj_name","title":"<code>PROJ_NAME</code>","text":"<p>Type: <code>str</code></p> <p>Value: <code>path.abspath(path.curdir).split(path.sep)[-1].upper()</code></p> SNIPPET Python<pre><code>PROJ_NAME: str = path.abspath(path.curdir).split(path.sep)[-1].upper()\n</code></pre>"},{"location":"mosheh/main.py/#repo_name","title":"<code>REPO_NAME</code>","text":"<p>Type: <code>str</code></p> <p>Value: <code>args.repo_name</code></p> SNIPPET Python<pre><code>REPO_NAME: str = args.repo_name\n</code></pre>"},{"location":"mosheh/main.py/#repo_url","title":"<code>REPO_URL</code>","text":"<p>Type: <code>str</code></p> <p>Value: <code>args.repo_url</code></p> SNIPPET Python<pre><code>REPO_URL: str = args.repo_url\n</code></pre>"},{"location":"mosheh/main.py/#edit_uri","title":"<code>EDIT_URI</code>","text":"<p>Type: <code>str</code></p> <p>Value: <code>args.edit_uri</code></p> SNIPPET Python<pre><code>EDIT_URI: str = args.edit_uri\n</code></pre>"},{"location":"mosheh/main.py/#logo_path","title":"<code>LOGO_PATH</code>","text":"<p>Type: <code>str | None</code></p> <p>Value: <code>args.logo_path</code></p> SNIPPET Python<pre><code>LOGO_PATH: str | None = args.logo_path\n</code></pre>"},{"location":"mosheh/main.py/#readme_path","title":"<code>README_PATH</code>","text":"<p>Type: <code>str | None</code></p> <p>Value: <code>args.readme_path</code></p> SNIPPET Python<pre><code>README_PATH: str | None = args.readme_path\n</code></pre>"},{"location":"mosheh/main.py/#output","title":"<code>OUTPUT</code>","text":"<p>Type: <code>str</code></p> <p>Value: <code>args.output</code></p> SNIPPET Python<pre><code>OUTPUT: str = args.output\n</code></pre>"},{"location":"mosheh/main.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"mosheh/main.py/#functions","title":"Functions","text":""},{"location":"mosheh/main.py/#def-set_logging_config","title":"<code>def set_logging_config</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>None</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>v: int</code></p> <p>Kwargs: <code>None</code></p> <p>Configures the logging level for the application based on the provided verbosity.</p> <p>Logging is handled using <code>RichHandler</code> for enhanced terminal output. The verbosity level <code>v</code> controls the logging granularity for the <code>mosheh</code> logger, and optionally for the <code>mkdocs</code> logger in debug mode.</p> <p>:param v: Verbosity level, from 0 (critical) to 4 (debug). Defaults to 3 (info). - 0: Critical - 1: Error - 2: Warning - 3: Info - 4: Debug</p> <p>:type v: int</p> <p>:returns: None.</p> <p>:rtype: None</p> SNIPPET Python<pre><code>def set_logging_config(v: int=3) -&gt; None:\n    \"\"\"\n    Configures the logging level for the application based on the provided verbosity.\n\n    Logging is handled using `RichHandler` for enhanced terminal output. The verbosity\n    level `v` controls the logging granularity for the `mosheh` logger, and optionally\n    for the `mkdocs` logger in debug mode.\n\n    :param v: Verbosity level, from 0 (critical) to 4 (debug). Defaults to 3 (info).\n        - 0: Critical\n        - 1: Error\n        - 2: Warning\n        - 3: Info\n        - 4: Debug\n    :type v: int\n    :returns: None.\n    :rtype: None\n    \"\"\"\n    basicConfig(format='%(message)s', handlers=[RichHandler()])\n    match v:\n        case 0:\n            getLogger('mosheh').setLevel(CRITICAL)\n        case 1:\n            getLogger('mosheh').setLevel(ERROR)\n        case 2:\n            getLogger('mosheh').setLevel(WARNING)\n        case 3:\n            getLogger('mosheh').setLevel(INFO)\n        case 4:\n            getLogger('mosheh').setLevel(DEBUG)\n        case _:\n            getLogger('mosheh').setLevel(INFO)\n</code></pre>"},{"location":"mosheh/main.py/#def-main","title":"<code>def main</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>None</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>None</code></p> <p>Kwargs: <code>None</code></p> <p>This is the script's entrypoint, kinda where everything starts.</p> <p>It takes no parameters inside code itself, but uses ArgumentParser to deal with them. Parsing the args, extracts the infos provided to deal and construct the output doc based on them.</p> <p>:rtype: None</p> SNIPPET Python<pre><code>def main() -&gt; None:\n    \"\"\"\n    This is the script's entrypoint, kinda where everything starts.\n\n    It takes no parameters inside code itself, but uses ArgumentParser to deal with\n    them. Parsing the args, extracts the infos provided to deal and construct the\n    output doc based on them.\n\n    :rtype: None\n    \"\"\"\n    parser: ArgumentParser = ArgumentParser(description=__doc__, formatter_class=RawDescriptionHelpFormatter)\n    parser.add_argument('-root', type=str, help='Root dir, where the analysis starts.', required=True)\n    parser.add_argument('--repo-name', type=str, default='GitHub', help='Name of the code repository to be mapped.')\n    parser.add_argument('--repo-url', type=str, default='https://github.com/', help='URL of the code repository to be mapped.')\n    parser.add_argument('--edit-uri', type=str, default='blob/main/documentation/docs', help='URI to view/edit raw/blob file.')\n    parser.add_argument('--logo-path', type=str, default=None, help='Path for doc/project logo, same Material MkDocs formats.')\n    parser.add_argument('--readme-path', type=str, default=None, help='Path for README.md file to replace as homepage.')\n    parser.add_argument('--verbose', type=int, default=3, help='Verbosity level, from 0 (quiet/critical) to 4 (overshare/debug).')\n    parser.add_argument('--output', type=str, default='.', help='Path for documentation output, where to be created.')\n    args: Namespace = parser.parse_args()\n    set_logging_config(args.verbose)\n    logger = getLogger('mosheh')\n    logger.info('Logger config done')\n    ROOT: str = args.root\n    logger.debug(f'ROOT = {ROOT!r}')\n    PROJ_NAME: str = path.abspath(path.curdir).split(path.sep)[-1].upper()\n    logger.debug(f'PROJ_NAME = {PROJ_NAME!r}')\n    REPO_NAME: str = args.repo_name\n    logger.debug(f'REPO_NAME = {REPO_NAME!r}')\n    REPO_URL: str = args.repo_url\n    logger.debug(f'REPO_URL = {REPO_URL!r}')\n    EDIT_URI: str = args.edit_uri\n    logger.debug(f'EDIT_URI = {EDIT_URI!r}')\n    LOGO_PATH: str | None = args.logo_path\n    logger.debug(f'LOGO_PATH = {LOGO_PATH!r}')\n    README_PATH: str | None = args.readme_path\n    logger.debug(f'README_PATH = {README_PATH!r}')\n    OUTPUT: str = args.output\n    logger.debug(f'OUTPUT = {OUTPUT!r}')\n    logger.info('Arguments parsed successfully')\n    logger.info(f'Starting to read codebase: {ROOT}')\n    data: CodebaseDict = read_codebase(ROOT)\n    logger.info('Codebase read successfully')\n    logger.info('Starting to generate documentation')\n    try:\n        generate_doc(codebase=data, root=ROOT, proj_name=PROJ_NAME, repo_name=REPO_NAME, repo_url=REPO_URL, edit_uri=EDIT_URI, logo_path=LOGO_PATH, readme_path=README_PATH, output=OUTPUT)\n        logger.info('Documentation created successfully')\n    except CalledProcessError as e:\n        logger.critical(e)\n</code></pre>"},{"location":"mosheh/main.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"mosheh/metadata.py/","title":"File: <code>metadata.py</code>","text":"<p>Role: Python Source Code</p> <p>Path: <code>mosheh</code></p> <p>If there is a file containing eater eggs and secrets, this one is not the one.</p> <p>Here are just info about Mosheh itself, data about data. No more than this.</p>"},{"location":"mosheh/metadata.py/#imports","title":"Imports","text":"<p>NO IMPORT DEFINED HERE</p>"},{"location":"mosheh/metadata.py/#consts","title":"Consts","text":""},{"location":"mosheh/metadata.py/#__author__","title":"<code>__author__</code>","text":"<p>Type: <code>Unknown</code></p> <p>Value: <code>'LucasGonc'</code></p> SNIPPET Python<pre><code>__author__ = 'LucasGonc'\n</code></pre>"},{"location":"mosheh/metadata.py/#__copyright__","title":"<code>__copyright__</code>","text":"<p>Type: <code>Unknown</code></p> <p>Value: <code>'Copyright (c) 2024 Lucas Gon\u00e7alves da Silva'</code></p> SNIPPET Python<pre><code>__copyright__ = 'Copyright (c) 2024 Lucas Gon\u00e7alves da Silva'\n</code></pre>"},{"location":"mosheh/metadata.py/#__credits__","title":"<code>__credits__</code>","text":"<p>Type: <code>Unknown</code></p> <p>Value: <code>['LucasGonc']</code></p> SNIPPET Python<pre><code>__credits__ = ['LucasGonc']\n</code></pre>"},{"location":"mosheh/metadata.py/#__license__","title":"<code>__license__</code>","text":"<p>Type: <code>Unknown</code></p> <p>Value: <code>'MIT'</code></p> SNIPPET Python<pre><code>__license__ = 'MIT'\n</code></pre>"},{"location":"mosheh/metadata.py/#__maintainer__","title":"<code>__maintainer__</code>","text":"<p>Type: <code>Unknown</code></p> <p>Value: <code>'LucasGonc'</code></p> SNIPPET Python<pre><code>__maintainer__ = 'LucasGonc'\n</code></pre>"},{"location":"mosheh/metadata.py/#__email__","title":"<code>__email__</code>","text":"<p>Type: <code>Unknown</code></p> <p>Value: <code>'lucasgoncsilva04@gmail.com'</code></p> SNIPPET Python<pre><code>__email__ = 'lucasgoncsilva04@gmail.com'\n</code></pre>"},{"location":"mosheh/metadata.py/#__repository__","title":"<code>__repository__</code>","text":"<p>Type: <code>Unknown</code></p> <p>Value: <code>'https://github.com/LucasGoncSilva/mosheh'</code></p> SNIPPET Python<pre><code>__repository__ = 'https://github.com/LucasGoncSilva/mosheh'\n</code></pre>"},{"location":"mosheh/metadata.py/#__keywords__","title":"<code>__keywords__</code>","text":"<p>Type: <code>Unknown</code></p> <p>Value: <code>['CLI', 'Python', 'documentation', 'MkDocs', 'automation', 'generation']</code></p> SNIPPET Python<pre><code>__keywords__ = ['CLI', 'Python', 'documentation', 'MkDocs', 'automation', 'generation']\n</code></pre>"},{"location":"mosheh/metadata.py/#__version__","title":"<code>__version__</code>","text":"<p>Type: <code>Unknown</code></p> <p>Value: <code>'1.3.3'</code></p> SNIPPET Python<pre><code>__version__ = '1.3.3'\n</code></pre>"},{"location":"mosheh/metadata.py/#__date__","title":"<code>__date__</code>","text":"<p>Type: <code>Unknown</code></p> <p>Value: <code>'2024-12-27'</code></p> SNIPPET Python<pre><code>__date__ = '2024-12-27'\n</code></pre>"},{"location":"mosheh/metadata.py/#__status__","title":"<code>__status__</code>","text":"<p>Type: <code>Unknown</code></p> <p>Value: <code>'Production'</code></p> SNIPPET Python<pre><code>__status__ = 'Production'\n</code></pre>"},{"location":"mosheh/metadata.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"mosheh/metadata.py/#functions","title":"Functions","text":"<p>NO FUNCTION DEFINED HERE</p>"},{"location":"mosheh/metadata.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"},{"location":"mosheh/utils.py/","title":"File: <code>utils.py</code>","text":"<p>Role: Python Source Code</p> <p>Path: <code>mosheh</code></p> <p>If a func can help and be classified as an \"utility function\" problably will be here.</p> <p>Functions to be here must be independent, work isolated from other ones and decoupled away from any external or global logic. They must work just by itself.</p> <p>Usually here are maintained reusable code applicable everywhere.</p>"},{"location":"mosheh/utils.py/#imports","title":"Imports","text":""},{"location":"mosheh/utils.py/#import-defaultdict","title":"<code>import defaultdict</code>","text":"<p>Path: <code>collections</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from collections import defaultdict\n</code></pre>"},{"location":"mosheh/utils.py/#import-sequence","title":"<code>import Sequence</code>","text":"<p>Path: <code>collections.abc</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from collections.abc import Sequence\n</code></pre>"},{"location":"mosheh/utils.py/#import-deepcopy","title":"<code>import deepcopy</code>","text":"<p>Path: <code>copy</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from copy import deepcopy\n</code></pre>"},{"location":"mosheh/utils.py/#import-find_spec","title":"<code>import find_spec</code>","text":"<p>Path: <code>importlib.util</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from importlib.util import find_spec\n</code></pre>"},{"location":"mosheh/utils.py/#import-any","title":"<code>import Any</code>","text":"<p>Path: <code>typing</code></p> <p>Category: Native</p> SNIPPET Python<pre><code>from typing import Any\n</code></pre>"},{"location":"mosheh/utils.py/#import-standardreturn","title":"<code>import StandardReturn</code>","text":"<p>Path: <code>custom_types</code></p> <p>Category: Local</p> SNIPPET Python<pre><code>from custom_types import StandardReturn\n</code></pre>"},{"location":"mosheh/utils.py/#consts","title":"Consts","text":"<p>NO CONSTANT DEFINED HERE</p>"},{"location":"mosheh/utils.py/#classes","title":"Classes","text":"<p>NO CLASS DEFINED HERE</p>"},{"location":"mosheh/utils.py/#functions","title":"Functions","text":""},{"location":"mosheh/utils.py/#def-bin","title":"<code>def bin</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>bool</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>item: Any, universe: Sequence[Any]</code></p> <p>Kwargs: <code>None</code></p> <p>Binary Search algorithm which returns not the index, but a boolean.</p> <p>It inicializes two \"pointers\", one for the low or start of the iterator and another for the high or the end of it. Gets the middle point and compares it with the asked item.</p> <p>If the item is greater/after the middle the middle becomes the new low and repeats, otherwise, it becomes the new high and so on and so on and so on... until the item is found and returns True or not, returning False.</p> <p>Example:</p> Python<pre><code>lst: list[int] = [1, 2, 3, 4, 5]\nnum: int = 4\nbin(num, lst)\n# True\n</code></pre> <p>:param item: The item to check if exists in.</p> <p>:type item: Any</p> <p>:param universe: The sorted iterable to be evaluated.</p> <p>:type universe: Sequence[Any]</p> <p>:return: If the item is found in the universe.</p> <p>:rtype: bool</p> SNIPPET Python<pre><code>def bin(item: Any, universe: Sequence[Any]) -&gt; bool:\n    \"\"\"\n    Binary Search algorithm which returns not the index, but a boolean.\n\n    It inicializes two \"pointers\", one for the low or start of the iterator\n    and another for the high or the end of it. Gets the middle point and\n    compares it with the asked item.\n\n    If the item is greater/after the middle the middle becomes the new low\n    and repeats, otherwise, it becomes the new high and so on and so on and\n    so on... until the item is found and returns True or not, returning False.\n\n    Example:\n    ```python\n    lst: list[int] = [1, 2, 3, 4, 5]\n    num: int = 4\n    bin(num, lst)\n    # True\n    ```\n\n    :param item: The item to check if exists in.\n    :type item: Any\n    :param universe: The sorted iterable to be evaluated.\n    :type universe: Sequence[Any]\n    :return: If the item is found in the universe.\n    :rtype: bool\n    \"\"\"\n    low: int = 0\n    high: int = len(universe) - 1\n    mid: int = 0\n    while low &lt;= high:\n        mid = (high + low) // 2\n        if universe[mid] &lt; item:\n            low = mid + 1\n        elif universe[mid] &gt; item:\n            high = mid - 1\n        else:\n            return True\n    return False\n</code></pre>"},{"location":"mosheh/utils.py/#def-is_lib_installed","title":"<code>def is_lib_installed</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>bool</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>name: str</code></p> <p>Kwargs: <code>None</code></p> <p>Checks if a lib exists in the environment path.</p> <p>By literally just... find spec using... unhh... find_spec()... searches for modules in the environment path and returns it.</p> <p>Example:</p> Python<pre><code>is_lib_installed('fastapi')\n# False\n</code></pre> <p>:param name: The name of the lib, e.g. numpy or numba.</p> <p>:type name: str</p> <p>:return: Whether the lib exists in the env.</p> <p>:rtype: bool</p> SNIPPET Python<pre><code>def is_lib_installed(name: str) -&gt; bool:\n    \"\"\"\n    Checks if a lib exists in the environment path.\n\n    By literally just... find spec using... unhh... find_spec()... searches\n    for modules in the environment path and returns it.\n\n    Example:\n    ```python\n    is_lib_installed('fastapi')\n    # False\n    ```\n\n    :param name: The name of the lib, e.g. numpy or numba.\n    :type name: str\n    :return: Whether the lib exists in the env.\n    :rtype: bool\n    \"\"\"\n    try:\n        return True if find_spec(name) is not None else False\n    except (ModuleNotFoundError, ValueError):\n        return False\n</code></pre>"},{"location":"mosheh/utils.py/#def-nested_dict","title":"<code>def nested_dict</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>defaultdict[Any, Any]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>None</code></p> <p>Kwargs: <code>None</code></p> <p>Creates and returns a nested dictionary using <code>collections.defaultdict</code>.</p> <p>This function generates a <code>defaultdict</code> where each key defaults to another <code>nested_dict</code>, allowing the creation of arbitrarily deep dictionaries without needing to explicitly define each level.</p> <p>Key concepts:</p> <ul> <li>defaultdict: A specialized dictionary from the <code>collections</code> module   that automatically assigns a default value for missing keys. In this case, the   default value is another <code>nested_dict</code>, enabling recursive dictionary nesting.</li> </ul> <p>Example:</p> Python<pre><code>d = nested_dict()\nd['level1']['level2']['level3'] = 'text'\n# {'level': {'level2': {'level3': 'text'}}}\n</code></pre> <p>:return: A <code>defaultdict</code> instance configured for recursive nesting.</p> <p>:rtype: defaultdict[Any, Any]</p> SNIPPET Python<pre><code>def nested_dict() -&gt; defaultdict[Any, Any]:\n    \"\"\"\n    Creates and returns a nested dictionary using `collections.defaultdict`.\n\n    This function generates a `defaultdict` where each key defaults to another\n    `nested_dict`, allowing the creation of arbitrarily deep dictionaries without\n    needing to explicitly define each level.\n\n    Key concepts:\n    - defaultdict: A specialized dictionary from the `collections` module\n      that automatically assigns a default value for missing keys. In this case, the\n      default value is another `nested_dict`, enabling recursive dictionary nesting.\n\n    Example:\n    ```python\n    d = nested_dict()\n    d['level1']['level2']['level3'] = 'text'\n    # {'level': {'level2': {'level3': 'text'}}}\n    ```\n\n    :return: A `defaultdict` instance configured for recursive nesting.\n    :rtype: defaultdict[Any, Any]\n    \"\"\"\n    return defaultdict(nested_dict)\n</code></pre>"},{"location":"mosheh/utils.py/#def-add_to_dict","title":"<code>def add_to_dict</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>defaultdict[Any, Any]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>structure: defaultdict[Any, Any], path: list[str], data: list[StandardReturn]</code></p> <p>Kwargs: <code>None</code></p> <p>Adds data to a nested dictionary structure based on a specified path.</p> <p>This function traverses a nested dictionary (<code>structure</code>) using a list of keys (<code>path</code>). If the path consists of a single key, the data is added directly to the corresponding level. Otherwise, the function recursively traverses deeper into the structure, creating nested dictionaries as needed, until the data is added at the specified location.</p> <p>Key concepts:</p> <ul> <li>Deepcopy: The <code>deepcopy</code> function is used to ensure that the <code>data</code> is safely   duplicated into the struc, avoiding unintended mutations of the original data.</li> <li>Recursive Traversal: The function calls itself recursively to traverse and modify   deeper levels of the nested dictionary.</li> </ul> <p>Example:</p> Python<pre><code>structure: defaultdict = nested_dict()\npath: list[str] = ['level1', 'level2', 'level3']\ndata: list[StandardReturn] = [{'key': 'value'}]\nadd_to_dict(structure, path, data)\n# defaultdict(defaultdict, {'level1': {'level2': {'level3': [{'key': 'value'}]}}})\n</code></pre> <p>:param structure: The nested dictionary to modify.</p> <p>:type structure: defaultdict[Any, Any]</p> <p>:param path: A list of keys representing the path to the target location.</p> <p>:type path: list[str]</p> <p>:param data: The data to add at the specified path.</p> <p>:type data: list[StandardReturn]</p> <p>:return: The modified dictionary with the new data added.</p> <p>:rtype: defaultdict[Any, Any]</p> SNIPPET Python<pre><code>def add_to_dict(structure: defaultdict[Any, Any], path: list[str], data: list[StandardReturn]) -&gt; defaultdict[Any, Any]:\n    \"\"\"\n    Adds data to a nested dictionary structure based on a specified path.\n\n    This function traverses a nested dictionary (`structure`) using a list of keys\n    (`path`). If the path consists of a single key, the data is added directly to the\n    corresponding level. Otherwise, the function recursively traverses deeper into the\n    structure, creating nested dictionaries as needed, until the data is added at the\n    specified location.\n\n    Key concepts:\n    - Deepcopy: The `deepcopy` function is used to ensure that the `data` is safely\n      duplicated into the struc, avoiding unintended mutations of the original data.\n    - Recursive Traversal: The function calls itself recursively to traverse and modify\n      deeper levels of the nested dictionary.\n\n    Example:\n    ```python\n    structure: defaultdict = nested_dict()\n    path: list[str] = ['level1', 'level2', 'level3']\n    data: list[StandardReturn] = [{'key': 'value'}]\n    add_to_dict(structure, path, data)\n    # defaultdict(defaultdict, {'level1': {'level2': {'level3': [{'key': 'value'}]}}})\n    ```\n\n    :param structure: The nested dictionary to modify.\n    :type structure: defaultdict[Any, Any]\n    :param path: A list of keys representing the path to the target location.\n    :type path: list[str]\n    :param data: The data to add at the specified path.\n    :type data: list[StandardReturn]\n    :return: The modified dictionary with the new data added.\n    :rtype: defaultdict[Any, Any]\n    \"\"\"\n    if len(path) == 1:\n        structure[path[0]] = deepcopy(data)\n    elif len(path) &gt; 1:\n        structure[path[0]] = add_to_dict(structure[path[0]], path[1:], data)\n    return structure\n</code></pre>"},{"location":"mosheh/utils.py/#def-convert_to_regular_dict","title":"<code>def convert_to_regular_dict</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>dict[Any, Any]</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>d: dict[Any, Any]</code></p> <p>Kwargs: <code>None</code></p> <p>Converts a nested <code>defaultdict</code> into a regular dictionary.</p> <p>This function recursively traverses a <code>defaultdict</code> and its nested dictionaries, converting all instances of <code>defaultdict</code> into standard Python dictionaries. This ensures the resulting structure is free of <code>defaultdict</code> behavior.</p> <p>Key concepts:</p> <ul> <li>defaultdict: A dictionary subclass from the <code>collections</code> module that provides   default values for missing keys. This func removes that behavior by converting   it into a regular dictionary.</li> <li>Recursive Conversion: The function traverses and converts all nested dict,   ensuring the entire structure is converted.</li> </ul> <p>Example:</p> Python<pre><code>d: defaultdict = nested_dict()\nd['level1']['level2'] = 'value'\nconvert_to_regular_dict(d)\n# {'level1': {'level2': 'value'}}\n</code></pre> <p>:param d: The dictionary to convert. Can include nested <code>defaultdict</code> instances.</p> <p>:type d: dict[Any, Any]</p> <p>:return: A dict where all <code>defaultdict</code> instances are converted to regular dicts.</p> <p>:rtype: dict[Any, Any]</p> SNIPPET Python<pre><code>def convert_to_regular_dict(d: dict[Any, Any]) -&gt; dict[Any, Any]:\n    \"\"\"\n    Converts a nested `defaultdict` into a regular dictionary.\n\n    This function recursively traverses a `defaultdict` and its nested dictionaries,\n    converting all instances of `defaultdict` into standard Python dictionaries. This\n    ensures the resulting structure is free of `defaultdict` behavior.\n\n    Key concepts:\n    - defaultdict: A dictionary subclass from the `collections` module that provides\n      default values for missing keys. This func removes that behavior by converting\n      it into a regular dictionary.\n    - Recursive Conversion: The function traverses and converts all nested dict,\n      ensuring the entire structure is converted.\n\n    Example:\n    ```python\n    d: defaultdict = nested_dict()\n    d['level1']['level2'] = 'value'\n    convert_to_regular_dict(d)\n    # {'level1': {'level2': 'value'}}\n    ```\n\n    :param d: The dictionary to convert. Can include nested `defaultdict` instances.\n    :type d: dict[Any, Any]\n    :return: A dict where all `defaultdict` instances are converted to regular dicts.\n    :rtype: dict[Any, Any]\n    \"\"\"\n    if isinstance(d, defaultdict):\n        d = {k: convert_to_regular_dict(v) for k, v in d.items()}\n    return d\n</code></pre>"},{"location":"mosheh/utils.py/#def-standard_struct","title":"<code>def standard_struct</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>StandardReturn</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>None</code></p> <p>Kwargs: <code>None</code></p> <p>Has the attribuition of returning an empty dict but maintaining the standard keys.</p> <p>The keys are listed below, followed by they types, as below:</p> Python<pre><code>dct: StandardReturn = {\n    'statement': Statement,\n    'name': str,\n    'tokens': Tokens,\n    'annot': str,\n    'value': str,\n    'decorators': Decorators,\n    'inheritance': Inheritance,\n    'path': str,\n    'category': ImportType | FunctionType,\n    'docstring': str | None,\n    'rtype': str,\n    'args': ArgsKwargs,\n    'kwargs': ArgsKwargs,\n    'test': str,\n    'msg': str,\n    'code': str,\n}\n</code></pre> <p>Any other datatype different from those above must be avoided as much as possible to maintain the codebase at the same struct. Python is not the best when talking about types like Java or Rust, so keep this in mind is really necessary.</p> <p>Example:</p> Python<pre><code>standard_struct()\n# {}\n</code></pre> <p>:return: An empty dict annotated with special custom type.</p> <p>:rtype: StandardReturn</p> SNIPPET Python<pre><code>def standard_struct() -&gt; StandardReturn:\n    \"\"\"\n    Has the attribuition of returning an empty dict but maintaining the standard keys.\n\n    The keys are listed below, followed by they types, as below:\n    ```python\n    dct: StandardReturn = {\n        'statement': Statement,\n        'name': str,\n        'tokens': Tokens,\n        'annot': str,\n        'value': str,\n        'decorators': Decorators,\n        'inheritance': Inheritance,\n        'path': str,\n        'category': ImportType | FunctionType,\n        'docstring': str | None,\n        'rtype': str,\n        'args': ArgsKwargs,\n        'kwargs': ArgsKwargs,\n        'test': str,\n        'msg': str,\n        'code': str,\n    }\n    ```\n    Any other datatype different from those above must be avoided as much as possible\n    to maintain the codebase at the same struct. Python is not the best when talking\n    about types like Java or Rust, so keep this in mind is really necessary.\n\n    Example:\n    ```python\n    standard_struct()\n    # {}\n    ```\n\n    :return: An empty dict annotated with special custom type.\n    :rtype: StandardReturn\n    \"\"\"\n    data: StandardReturn = {}\n    return data\n</code></pre>"},{"location":"mosheh/utils.py/#def-indent_code","title":"<code>def indent_code</code>","text":"<p>Type: <code>Function</code></p> <p>Return Type: <code>str</code></p> <p>Decorators: <code>None</code></p> <p>Args: <code>code: str, level: int</code></p> <p>Kwargs: <code>None</code></p> Text Only<pre><code>Used just for applying indentation to code before building the doc `.md` file.\n\nBy receiving the code itself and an indentation number, defaulting to 4, and for\neach line applies the desired indentation level, A.K.A leftpad.\n\nExample:\n```python\ncode: str = \"\"\"for i in range(10):\n            str(i)\"\"\"\nlevel: int = 4\ncode\n# for i in range(10):\n</code></pre>"},{"location":"mosheh/utils.py/#stri","title":"str(i)","text":"Text Only<pre><code>indent_code(code, level)\n#     for i in range(10):\n</code></pre>"},{"location":"mosheh/utils.py/#stri_1","title":"str(i)","text":"Text Only<pre><code>```\n</code></pre> <p>:param code: The code snippet to be formatted.</p> <p>:type code: str</p> <p>:param level: The number of spaces to leftpad each line.</p> <p>:type level: int</p> <p>:return: The code snippet leftpadded.</p> <p>:rtype: str</p> SNIPPET Python<pre><code>def indent_code(code: str, level: int=4) -&gt; str:\n    '''\n    Used just for applying indentation to code before building the doc `.md` file.\n\n    By receiving the code itself and an indentation number, defaulting to 4, and for\n    each line applies the desired indentation level, A.K.A leftpad.\n\n    Example:\n    ```python\n    code: str = \"\"\"for i in range(10):\n        str(i)\"\"\"\n    level: int = 4\n    code\n    # for i in range(10):\n#     str(i)\n    indent_code(code, level)\n    #     for i in range(10):\n#         str(i)\n    ```\n\n    :param code: The code snippet to be formatted.\n    :type code: str\n    :param level: The number of spaces to leftpad each line.\n    :type level: int\n    :return: The code snippet leftpadded.\n    :rtype: str\n    '''\n    indent = ' ' * level\n    new_code = '\\n'.join(map(lambda line: f'{indent}{line}' if line.strip() else '', code.splitlines()))\n    return new_code\n</code></pre>"},{"location":"mosheh/utils.py/#assertions","title":"Assertions","text":"<p>NO ASSERT DEFINED HERE</p>"}]}